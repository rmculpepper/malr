<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>3&nbsp;Basic Shapes</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Macros and Languages in Racket</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="intro.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="shapes.html" class="tocviewlink" data-pltdoc="x">Terms and Shapes</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Basic Shapes</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="compound-shapes.html" class="tocviewlink" data-pltdoc="x">Compound Shapes</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="defshape.html" class="tocviewlink" data-pltdoc="x">Shape Definitions</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="enum-shapes.html" class="tocviewlink" data-pltdoc="x">Enumerated Shapes</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="multi-shapes.html" class="tocviewlink" data-pltdoc="x">Multi-<wbr></wbr>Term Shapes</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="rec-shapes.html" class="tocviewlink" data-pltdoc="x">Recursive Shapes</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="compile-time.html" class="tocviewlink" data-pltdoc="x">Compile-<wbr></wbr>Time Computation and Information</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="unhygienic.html" class="tocviewlink" data-pltdoc="x">Unhygienic Macros</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Basic Shapes</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">3.1&nbsp;</td><td><a href="#%28part._basic-expr%29" class="tocviewlink" data-pltdoc="x">The Expr (Expression) Shape</a></td></tr><tr><td align="right">3.2&nbsp;</td><td><a href="#%28part._basic-body%29" class="tocviewlink" data-pltdoc="x">The Body Shape</a></td></tr><tr><td align="right">3.3&nbsp;</td><td><a href="#%28part._basic-hygiene2%29" class="tocviewlink" data-pltdoc="x">Proper Lexical Scoping, Part 2</a></td></tr><tr><td align="right">3.4&nbsp;</td><td><a href="#%28part._basic-id%29" class="tocviewlink" data-pltdoc="x">The Id (Identifier) Shape</a></td></tr><tr><td align="right">3.5&nbsp;</td><td><a href="#%28part._basic-type%29" class="tocviewlink" data-pltdoc="x">Expressions, Types, and Contracts</a></td></tr><tr><td align="right">3.6&nbsp;</td><td><a href="#%28part._basic-expr-uses%29" class="tocviewlink" data-pltdoc="x">Uses of Expressions</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._basic-expr%29" class="tocsubseclink" data-pltdoc="x">The Expr (Expression) Shape</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._basic-body%29" class="tocsubseclink" data-pltdoc="x">The Body Shape</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._basic-hygiene2%29" class="tocsubseclink" data-pltdoc="x">Proper Lexical Scoping, Part 2</a></td></tr><tr><td><span class="tocsublinknumber">3.4<tt>&nbsp;</tt></span><a href="#%28part._basic-id%29" class="tocsubseclink" data-pltdoc="x">The Id (Identifier) Shape</a></td></tr><tr><td><span class="tocsublinknumber">3.5<tt>&nbsp;</tt></span><a href="#%28part._basic-type%29" class="tocsubseclink" data-pltdoc="x">Expressions, Types, and Contracts</a></td></tr><tr><td><span class="tocsublinknumber">3.6<tt>&nbsp;</tt></span><a href="#%28part._basic-expr-uses%29" class="tocsubseclink" data-pltdoc="x">Uses of Expressions</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="shapes.html" title="backward to &quot;2 Terms and Shapes&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Macros and Languages in Racket&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="compound-shapes.html" title="forward to &quot;4 Compound Shapes&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>3<tt>&nbsp;</tt><a name="(part._basic-shapes)"></a>Basic Shapes</h3><p>This section introduces the most important basic shapes for macro design.</p><h4>3.1<tt>&nbsp;</tt><a name="(part._basic-expr)"></a>The Expr (Expression) Shape</h4><p>The <span class="RktCmt">Expr</span> shape represents the intention to interpret the term as a
Racket expression by putting it in an expression context. In general, a macro
cannot check a term and decide whether it is a valid expression; only the Racket
macro expander can do that. As a pragmatic approximation, the <span class="RktCmt">Expr</span> shape
and its associated <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span> syntax class exclude only keyword terms, like
<span class="RktPn">#:when</span>, so that macros can detect and report misuses of keyword
arguments.</p><p><div class="SIntrapara">As an example, let&rsquo;s implement <span class="RktSym">my-when</span>, a simple version of Racket&rsquo;s
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._when%29%29" class="RktStxLink" data-pltdoc="x">when</a></span> form. It takes two expressions; the first is the condition, and
the second is the result to be evaluated only if the condition is true. Here is
the shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-when</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Here are some examples:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"odd!\n"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect print</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"even!\n"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect no print</span></td></tr></table></blockquote></div><div class="SIntrapara">Here&rsquo;s the implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-when</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="hspace">&nbsp;</span><span class="RktSym">result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">We use the <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span> syntax class to annotate pattern variables that have
the <span class="RktCmt">Expr</span> shape. Note that the names of the pattern variables do not
include the <span class="RktSym">:expr</span> annotation, so in the syntax template we simply
write <span class="RktSym">condition</span> and <span class="RktSym">result</span>.</div></p><p><div class="SIntrapara">To test the macro, we rephrase the previous examples as tests:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"odd!\n"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">"odd!\n"</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"even!\n"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">""</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-exn%29%29" class="RktValLink" data-pltdoc="x">check-exn</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._exn~3afail~3asyntax~3f%29%29" class="RktValLink" data-pltdoc="x">exn:fail:syntax?</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/macro-testing.html#%28form._%28%28lib._syntax%2Fmacro-testing..rkt%29._convert-syntax-error%29%29" class="RktStxLink" data-pltdoc="x">convert-syntax-error</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">#:truth</span><span class="hspace">&nbsp;</span><span class="RktVal">"verity"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote></div></p><blockquote class="SubFlow"><p><div class="SIntrapara"><a name="(exercise._basic~3ashape-violation)"></a><span style="font-weight: bold">Exercise&#160;1: </span>Each of the following uses of
<span class="RktSym">my-when</span> violates its declared shape:
</div><div class="SIntrapara"><ul><li><p><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="stt"> </span><span class="RktPn">#:true</span><span class="stt"> </span><span class="RktVal">"verity"</span><span class="RktPn">)</span></p></li><li><p><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">ok</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="stt"> </span><span class="RktSym">ns</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktVal">3</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="stt"> </span><span class="RktSym">ns</span><span class="RktPn">)</span><span class="RktPn">)</span></p></li><li><p><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin%29%29" class="RktStxLink" data-pltdoc="x">begin</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="stt"> </span><span class="RktSym">one</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktSym">one</span><span class="stt"> </span><span class="RktSym">one</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></li><li><p><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="stt"> </span><span class="RktVal">#f</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktPn">#:one</span><span class="stt"> </span><span class="RktPn">#:two</span><span class="RktPn">)</span><span class="RktPn">)</span></p></li></ul></div><div class="SIntrapara">Why? Which examples are rejected by the <span class="RktSym">my-when</span> macro itself, and
what happens to the other examples? What difference does it make if you remove
the <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span> syntax class annotations from the macro definition?</div></p></blockquote><blockquote class="SubFlow"><p><a name="(exercise._basic~3amy-unless)"></a><span style="font-weight: bold">Exercise&#160;2: </span>Design a macro <span class="RktSym">my-unless</span> like
<span class="RktSym">my-when</span>, except that it negates the condition.</p></blockquote><blockquote class="SubFlow"><p><a name="(exercise._basic~3acatch-output)"></a><span style="font-weight: bold">Exercise&#160;3: </span>Design a macro <span class="RktSym">catch-output</span> that
takes a single expression argument. The expression is evaluated, but its result
is ignored; instead, the result of the macro is a string containing all of the
output written by the expression. For example:</p><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">catch-output</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/for.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._for%29%29" class="RktStxLink" data-pltdoc="x">for</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">i</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"~s"</span><span class="hspace">&nbsp;</span><span class="RktSym">i</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect "0123456789"</span></p></blockquote></blockquote><h4>3.2<tt>&nbsp;</tt><a name="(part._basic-body)"></a>The Body Shape</h4><p>The <span class="RktCmt">Body</span> shape is like <span class="RktCmt">Expr</span> except that it indicates that the
term will be used in a body context, so definitions are allowed in addition to
expressions.</p><p>There is no distinct syntax class for <span class="RktCmt">Body</span>; just use <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span>.</p><p>In practice, the <span class="RktCmt">Body</span> shape is usually used with ellipses; see
<a href="compound-shapes.html" data-pltdoc="x">Compound Shapes</a>. But we can make a version of <span class="RktSym">my-when</span> that
takes a single <span class="RktCmt">Body</span> term, even though it isn&rsquo;t idiomatic Racket
syntax. Here is the shape:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-when</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Body)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote><p><div class="SIntrapara">Here is an example allowed by the new shape but not by the previous shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">37</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin%29%29" class="RktStxLink" data-pltdoc="x">begin</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">q</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._quotient%29%29" class="RktValLink" data-pltdoc="x">quotient</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"q = ~s\n"</span><span class="hspace">&nbsp;</span><span class="RktSym">q</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Given the new shape, the previous implementation would be wrong, since it
does not place its second argument in a body context. Here is an updated
implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-when</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result-body:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/block.html#%28form._%28%28lib._racket%2Fblock..rkt%29._block%29%29" class="RktStxLink" data-pltdoc="x">block</a></span><span class="hspace">&nbsp;</span><span class="RktSym">result-body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>That is, use <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/block.html#%28form._%28%28lib._racket%2Fblock..rkt%29._block%29%29" class="RktStxLink" data-pltdoc="x">block</a></span><span class="stt"> </span><span style="color: lightgray">&#9251;</span><span class="RktPn">)</span> to wrap a <span class="RktCmt">Body</span> so it can be used in a
strict <span class="RktCmt">Expr</span> position. It is also common to use a <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">)</span><span class="stt"> </span><span style="color: lightgray">&#9251;</span><span class="RktPn">)</span>
wrapper, but that does not work for all <span class="RktCmt">Body</span> terms; it requires that the
<span class="RktCmt">Body</span> term ends with an expression. The <span class="RktSym"><a href="https://docs.racket-lang.org/reference/block.html#%28form._%28%28lib._racket%2Fblock..rkt%29._block%29%29" class="RktStxLink" data-pltdoc="x">block</a></span> form is more
flexible.</p><p><div class="SIntrapara">Racket&rsquo;s <span class="RktSym"><a href="https://docs.racket-lang.org/reference/__expression.html#%28form._%28%28quote._~23~25kernel%29._~23~25expression%29%29" class="RktStxLink" data-pltdoc="x">#%expression</a></span> form is useful in the opposite situation. It has
the following shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(#%expression</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Body</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">That is, use <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/__expression.html#%28form._%28%28quote._~23~25kernel%29._~23~25expression%29%29" class="RktStxLink" data-pltdoc="x">#%expression</a></span><span class="stt"> </span><span style="color: lightgray">&#9251;</span><span class="RktPn">)</span> to turn a <span class="RktCmt">Body</span> position into a
strict <span class="RktCmt">Expr</span> position.</div></p><blockquote class="SubFlow"><p><div class="SIntrapara"><a name="(exercise._basic~3acatch-output-expr)"></a><span style="font-weight: bold">Exercise&#160;4: </span>Check your solution to
<a href="#%28exercise._basic~3acatch-output%29" data-pltdoc="x">Exercise&#160;3</a>; does the macro also accept <span class="RktCmt">Body</span>
terms like the one above? That is, does the following work?
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">catch-output</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin%29%29" class="RktStxLink" data-pltdoc="x">begin</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">q</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._quotient%29%29" class="RktValLink" data-pltdoc="x">quotient</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"q = ~s\n"</span><span class="hspace">&nbsp;</span><span class="RktSym">q</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></div><div class="SIntrapara">If so, &ldquo;fix it&rdquo; (that is, make it more restrictive) using
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/__expression.html#%28form._%28%28quote._~23~25kernel%29._~23~25expression%29%29" class="RktStxLink" data-pltdoc="x">#%expression</a></span>.</div></p></blockquote><h4>3.3<tt>&nbsp;</tt><a name="(part._basic-hygiene2)"></a>Proper Lexical Scoping, Part 2</h4><p><div class="SIntrapara">Here is one solution to <a href="#%28exercise._basic~3acatch-output%29" data-pltdoc="x">Exercise&#160;3</a> using
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(catch-output Expr) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">catch-output</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">e:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/__expression.html#%28form._%28%28quote._~23~25kernel%29._~23~25expression%29%29" class="RktStxLink" data-pltdoc="x">#%expression</a></span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Racket already provides <span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span> from the
<a href="https://docs.racket-lang.org/reference/port-lib.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">racket/port</span></a> library, but if it did not, we could define it as
follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">with-output-to-string : (-&gt; Any) -&gt; String</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">proc</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">out</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stringport.html#%28def._%28%28quote._~23~25kernel%29._open-output-string%29%29" class="RktValLink" data-pltdoc="x">open-output-string</a></span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/parameters.html#%28form._%28%28lib._racket%2Fprivate%2Fmore-scheme..rkt%29._parameterize%29%29" class="RktStxLink" data-pltdoc="x">parameterize</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-ops.html#%28def._%28%28quote._~23~25kernel%29._current-output-port%29%29" class="RktValLink" data-pltdoc="x">current-output-port</a></span><span class="hspace">&nbsp;</span><span class="RktSym">out</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">proc</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stringport.html#%28def._%28%28quote._~23~25kernel%29._get-output-string%29%29" class="RktValLink" data-pltdoc="x">get-output-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">out</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here is another implementation of <span class="RktSym">catch-output</span>, which essentially
inlines the definition of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span> into the macro
template:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(catch-output Expr) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">catch-output</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">e:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">out</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stringport.html#%28def._%28%28quote._~23~25kernel%29._open-output-string%29%29" class="RktValLink" data-pltdoc="x">open-output-string</a></span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/parameters.html#%28form._%28%28lib._racket%2Fprivate%2Fmore-scheme..rkt%29._parameterize%29%29" class="RktStxLink" data-pltdoc="x">parameterize</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-ops.html#%28def._%28%28quote._~23~25kernel%29._current-output-port%29%29" class="RktValLink" data-pltdoc="x">current-output-port</a></span><span class="hspace">&nbsp;</span><span class="RktSym">out</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/__expression.html#%28form._%28%28quote._~23~25kernel%29._~23~25expression%29%29" class="RktStxLink" data-pltdoc="x">#%expression</a></span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stringport.html#%28def._%28%28quote._~23~25kernel%29._get-output-string%29%29" class="RktValLink" data-pltdoc="x">get-output-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">out</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">In <a href="intro.html#%28part._intro-lexical%29" data-pltdoc="x">Proper Lexical Scoping</a> we saw that we cannot interfere with a macro&rsquo;s
&ldquo;free variables&rdquo; by shadowing them at the macro use site. For example, the
following attempt to capture the macro&rsquo;s reference to <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stringport.html#%28def._%28%28quote._~23~25kernel%29._get-output-string%29%29" class="RktValLink" data-pltdoc="x">get-output-string</a></span>
fails:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stringport.html#%28def._%28%28quote._~23~25kernel%29._get-output-string%29%29" class="RktValLink" data-pltdoc="x">get-output-string</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"pwned!"</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">catch-output</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"doing just fine, actually"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">"doing just fine, actually"</span></p></td></tr></table></blockquote></div></p><p>But what about the other direction? The macro introduces a binding of a variable
named <span class="RktSym">out</span>; could this binding capture references to <span class="RktSym">out</span> in the
expression given to the macro? Here is an example:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">out</span><span class="hspace">&nbsp;</span><span class="RktVal">"Aisle 24"</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">catch-output</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"The exit is located at ~a."</span><span class="hspace">&nbsp;</span><span class="RktSym">out</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">"The exit is located at Aisle 24."</span></p></td></tr></table></blockquote><p>The result shows that the macro&rsquo;s <span class="RktSym">out</span> binding does not interfere with
the use-site&rsquo;s <span class="RktSym">out</span> variable. We say that the <span class="RktSym">catch-output</span>
macro is &ldquo;hygienic&rdquo;.</p><p><div class="SIntrapara">A macro is <a name="(tech._hygienic)"></a><span style="font-style: italic">hygienic</span> if it follows these two lexical scoping principles:
</div><div class="SIntrapara"><ol><li><p>A <span class="emph">use-site binding</span> does not capture a <span class="emph">definition-site
reference</span>.</p></li><li><p>A <span class="emph">definition-site binding</span> does not capture a <span class="emph">use-site
reference</span>.</p></li></ol></div><div class="SIntrapara">Racket macros are hygienic by default. In FIXME-REF we will discuss a few
situations when it is useful to break hygiene.</div></p><h4>3.4<tt>&nbsp;</tt><a name="(part._basic-id)"></a>The Id (Identifier) Shape</h4><p>The <span class="RktCmt">Id</span> shape contains all identifier terms.</p><p>The <span class="RktCmt">Id</span> shape usually implies that the identifier will be used as the
name for a variable, macro, or other sort of binding. In that case, we say the
identifer is used as a <span class="emph">binder</span>.</p><p>Use the <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._id%29%29" class="RktStxLink" data-pltdoc="x">id</a></span> syntax class for pattern variables whose shape is <span class="RktCmt">Id</span>.</p><p><div class="SIntrapara">Let&rsquo;s write a macro <span class="RktSym">my-and-let</span> that acts like <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._and%29%29" class="RktStxLink" data-pltdoc="x">and</a></span> with two
expressions but binds the result of the first expression to the given identifier
before evaluating the second expression. Here is the shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-and-let</span><span class="hspace">&nbsp;</span><span class="RktCmt">Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Here are some examples:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">a</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">c</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-and-let</span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._assoc%29%29" class="RktValLink" data-pltdoc="x">assoc</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect 2</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-and-let</span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._assoc%29%29" class="RktValLink" data-pltdoc="x">assoc</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">z</span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect #f</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here is an implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-and-let</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">e1:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">e2:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e1</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e2</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">The main point of <span class="RktSym">my-and-let</span>, though, is that if the second expression
is evaluated, it is evaluated in an environment where the identifier is bound to
the value of the first expression. Let&rsquo;s put that information in the shape of
<span class="RktSym">my-and-let</span>. It requires two changes:
</div><div class="SIntrapara"><ul><li><p>Label the identifier so we can refer to it later. So instead of
<span class="RktCmt">Id</span>, we write <span class="RktCmt">x:Id</span>. The label does not have to be the same as
the name of the pattern variable, but it makes sense to use the same name here.</p></li><li><p>Add an <span class="emph">environment annotation</span> to the second <span class="RktCmt">Expr</span> indicating
that it&rsquo;s in the scope of a variable whose name is whatever actual identifier
<span class="RktCmt">x</span> refers to: <span class="RktCmt">Expr{x}</span>.</p></li></ul></div></p><p><div class="SIntrapara">Here is the updated shape for <span class="RktSym">my-and-let</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-and-let</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x})</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>We can check the implementation: <span class="RktSym">e1</span> does not occur in the scope of
<span class="RktSym">x</span>, and <span class="RktSym">e2</span> does occur in the scope of <span class="RktSym">x</span>.</p><p><div class="SIntrapara">Here is another implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-and-let x:Id Expr Expr{x}) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-and-let</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">e1:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">e2:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e1</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">BAD</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e2</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">This implementation is <span class="emph">wrong</span>, because <span class="RktSym">e1</span> occurs in the scope of
<span class="RktSym">x</span>, but it should not.</div></p><p><div class="SIntrapara">Here is another version:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-and-let x:Id Expr Expr{x}) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-and-let</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">e1:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">e2:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktSym">e1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>This implementation is good (although more complicated than unnecessary),
because <span class="RktSym">e1</span> no longer occurs in the scope of <span class="RktSym">x</span>. But what about
<span class="RktSym">tmp</span>? Because of hygiene, the definition of <span class="RktSym">tmp</span> introduced by
the macro is not visible to <span class="RktSym">e1</span>. (To be clear, it would be <span class="emph">wrong</span>
to write <span class="RktCmt">Expr{tmp}</span> for the shape of the first expression.)</p><blockquote class="SubFlow"><p><div class="SIntrapara"><a name="(exercise._basic~3aif-let)"></a><span style="font-weight: bold">Exercise&#160;5: </span>Generalize <span class="RktSym">my-and-let</span> to
<span class="RktSym">my-if-let</span>, which takes an extra expression argument which is the
macro&rsquo;s result if the condition is false. The macro should have the following
shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-if-let</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x}</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Double-check your solution to make sure it follows the scoping specified by the
shape.</div></p></blockquote><h4>3.5<tt>&nbsp;</tt><a name="(part._basic-type)"></a>Expressions, Types, and Contracts</h4><p><div class="SIntrapara">Let&rsquo;s design the macro <span class="RktSym">my-match-pair</span>, which takes an expression to
destructure, two identifiers to bind as variables, and a result expression. Here
are some examples:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">ns</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3c%29%29" class="RktValLink" data-pltdoc="x">&lt;</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ns</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect #t</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">p</span><span class="hspace">&nbsp;</span><span class="RktVal">"hello world"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">tag</span><span class="hspace">&nbsp;</span><span class="RktSym">content</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._format%29%29" class="RktValLink" data-pltdoc="x">format</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"&lt;~a&gt;~a&lt;/~a&gt;"</span><span class="hspace">&nbsp;</span><span class="RktSym">tag</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/strings.html#%28def._%28%28lib._racket%2Fstring..rkt%29._string-join%29%29" class="RktValLink" data-pltdoc="x">string-join</a></span><span class="hspace">&nbsp;</span><span class="RktSym">content</span><span class="hspace">&nbsp;</span><span class="RktVal">" "</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">tag</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect "&lt;p&gt;hello world&lt;/p&gt;"</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here is one shape we could write for <span class="RktSym">my-match-pair</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">xs:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x,xs})</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here&rsquo;s an implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-match-pair</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">xs:id</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">pair-v</span><span class="hspace">&nbsp;</span><span class="RktSym">pair</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">xs</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Note that we introduce a <span class="emph">temporary variable</span> (or <span class="emph">auxiliary
variable</span>) named <span class="RktSym">pair-v</span> to avoid evaluating the <span class="RktSym">pair</span>
expression twice.</p><p><div class="SIntrapara">We could add more information to the shape. The macro expects the first argument
to be a pair, and whatever types of values the pair contains become the types of
the identifiers:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr[(cons</span><span class="hspace">&nbsp;</span><span class="RktCmt">T1</span><span class="hspace">&nbsp;</span><span class="RktCmt">T2)]</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">xs:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x:T1,xs:T2})</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">I&rsquo;ve written <span class="RktCmt">Expr[(cons T1 T2)]</span> for the shape of expressions of type
<span class="RktCmt">(cons T1 T2)</span>, where the type <span class="RktCmt">(cons T1 T2)</span> is the type of all pairs
(values made with the <span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span> constructor) whose first component has type
<span class="RktCmt">T1</span> and whose second component has type <span class="RktCmt">T2</span>. The second expression&rsquo;s
environment annotation includes the types of the variables. This macro shape is
polymorphic; there is an implicit <span class="RktCmt">forall (T1, T2)</span> at the beginning of
the declaration.</div></p><p><div class="SIntrapara">The result of the macro is the result of the second expression, so the type of
the macro is the same as the type of the second expression. We could add that
to the shape too:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr[(cons</span><span class="hspace">&nbsp;</span><span class="RktCmt">T1</span><span class="hspace">&nbsp;</span><span class="RktCmt">T2)]</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">xs:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x:T1,xs:T2}[R])</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr[R]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Now the second <span class="RktCmt">Expr</span> has both a environment annotation and a type
annotation.</div></p><p>When I say &ldquo;type&rdquo; here, I&rsquo;m not talking about Typed Racket or some other typed
language implemented in Racket, nor do I mean that there&rsquo;s a super-secret type
checker hidden somewhere in Racket next to a flight simulator. By &ldquo;type&rdquo; I
mean a semi-formal, unchecked description of expressions and macros that
manipulate them. In this case, the shape declaration for <span class="RktSym">my-match-pair</span>
warns the user that the first argument must produce a pair. If it doesn&rsquo;t, the
user has failed their obligations, and the macro may do bad things.</p><p>Of course, given human limitations, we would prefer the macro not to do bad
things. Ideally, the macro definition and macro uses could be statically checked
for compliance with shape declarations, but Racket does not not implement such a
checker for macros. (It&rsquo;s complicated.) At least, though, the macro enforce
approximations of the types of expression arguments using <span class="emph">contracts</span>.</p><p>Use the <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28def._%28%28lib._syntax%2Fparse..rkt%29._expr%2Fc%29%29" class="RktValLink" data-pltdoc="x">expr/c</a></span> syntax class for a pattern variable whose shape is
<span class="RktCmt">Expr[Type]</span> when <span class="RktCmt">Type</span> has a useful contract approximation. In this
example, the type <span class="RktCmt">(cons T1 T2)</span> has a useful contract approximation
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span>, but there is no useful contract for the type <span class="RktCmt">R</span>. The
<span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28def._%28%28lib._syntax%2Fparse..rkt%29._expr%2Fc%29%29" class="RktValLink" data-pltdoc="x">expr/c</a></span> syntax class takes an argument, so you cannot use the
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">:</span><span class="hspace"></span></span> notation; you must use <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7evar%29%29" class="RktStxLink" data-pltdoc="x">~var</a></span> or <span class="RktPn">#:declare</span>
instead. The argument is a syntax object representing the contract to apply to
the expression. (It is <span class="RktRdr">#'</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span> instead of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span> because the
contract check is performed at run time.) In the syntax template, use the
<span class="RktSym">c</span> ("contracted") <span class="emph">attribute</span> of the pattern variable to get the
expression with a contract-checking wrapper. Here&rsquo;s the contract-checked version
of the macro:</p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-match-pair Expr[(cons T1 T2)] x:Id xs:Id Expr{x:T1,xs:T2}[R]) : Expr[R]</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-match-pair</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7evar%29%29" class="RktStxLink" data-pltdoc="x">~var</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28def._%28%28lib._syntax%2Fparse..rkt%29._expr%2Fc%29%29" class="RktValLink" data-pltdoc="x">expr/c</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">xs:id</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">pair-v</span><span class="hspace">&nbsp;</span><span class="RktSym">pair.c</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Important: pair.c, not pair</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">xs</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Here&rsquo;s the implementation using <span class="RktPn">#:declare</span> instead of <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7evar%29%29" class="RktStxLink" data-pltdoc="x">~var</a></span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-match-pair</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair</span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">xs:id</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:declare</span><span class="hspace">&nbsp;</span><span class="RktSym">pair</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28def._%28%28lib._syntax%2Fparse..rkt%29._expr%2Fc%29%29" class="RktValLink" data-pltdoc="x">expr/c</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">pair-v</span><span class="hspace">&nbsp;</span><span class="RktSym">pair.c</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Important: pair.c, not pair</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">xs</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Now calling <span class="RktSym">my-match-pair</span> raises a contract violation if the first
expression does not produce a pair. For example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">not-a-pair</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">ns</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">my-match-pair: contract violation</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: pair?</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">given: 'not-a-pair</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">in: pair?</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">macro argument contract</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">contract from: top-level</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">blaming: top-level</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">(assuming the contract is correct)</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">at: eval:32:0</span></p></td></tr></table></blockquote></div></p><blockquote class="SubFlow"><p><a name="(exercise._basic~3amy-when-contract)"></a><span style="font-weight: bold">Exercise&#160;6: </span>Modify the <span class="RktSym">my-when</span> macro to
check that the condition expression produces a boolean value. (Note: this is not
idiomatic for Racket conditional macros).</p></blockquote><h4>3.6<tt>&nbsp;</tt><a name="(part._basic-expr-uses)"></a>Uses of Expressions</h4><p><div class="SIntrapara">In general, what can a macro do with an expression (<span class="RktCmt">Expr</span>)?
</div><div class="SIntrapara"><ul><li><p>It can use the value (or values) that the expression evaluates to. For
example, the behavior of the <span class="RktSym">my-when</span> macro depends on the value that
its first expression produces.</p></li><li><p>It can determine whether the expression is evaluated or when the
expression is evaluated. The <span class="RktSym">my-when</span> example determines whether to
evaluate its second expression. The standard <span class="RktSym">delay</span> macro is a classic
example of controlling when an expression is evaluated.</p></li><li><p>It can change what dynamic context the expression is evaluated within. For
example, a macro could use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/parameters.html#%28form._%28%28lib._racket%2Fprivate%2Fmore-scheme..rkt%29._parameterize%29%29" class="RktStxLink" data-pltdoc="x">parameterize</a></span> to evaluate the expression in a
context with different values for some parameters.</p></li><li><p>It can change the static context the expression is evaluated
within. Mainly, this means putting the expression in the scope of additional
bindings, as we did in <span class="RktSym">my-and-let</span> and <span class="RktSym">my-match-pair</span>.</p></li></ul></div></p><p>There are some restrictions on what macros can do and should do with expressions:</p><ul><li><p><span style="font-weight: bold">A macro cannot get the value of the expression at compile time.</span> The
expression represents computation that will occur later, at run time, perhaps on
different machines, perhaps many times with different values in the run-time
environment. A macro can only interact with an expression&rsquo;s value by producing
code to process the value at run time.</p></li><li><p><span style="font-weight: bold">A macro must not look at the contents of the expression itself.</span>
Expressions are macro-extensible, so there is no grammar to guide case
analysis. Interpreting expressions is the macro expander&rsquo;s business, so don&rsquo;t
try it yourself. The macro expander is complicated, and if you attempt to
duplicate its work &ldquo;just a little&rdquo;, you are likely to make unjustified
assumptions and get it wrong. For example, an expression consisting of a
self-quoting datum is not necessarily a constant, or even free of side effects;
it might have a nonstandard <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._~23~25datum%29%29" class="RktStxLink" data-pltdoc="x">#%datum</a></span> binding, which could give it any
behavior at all. Likewise, a plain identifier is not necessarily a variable
reference; it might be an identifier macro, or it might have a nonstandard
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/__top.html#%28form._%28%28quote._~23~25kernel%29._~23~25top%29%29" class="RktStxLink" data-pltdoc="x">#%top</a></span> binding.</p><p>In later sections (FIXME-REF), we&rsquo;ll talk about how to cooperate with
the macro expander to do case analysis of expressions and other forms.</p></li><li><p>In general, a macro should not duplicate an argument expression. That is,
the expression should occur exactly once in the macro&rsquo;s expansion. Duplicating
expressions leads to expanding the same code multiple times, which can lead to
slow compilation and bloated compiled code. The increases to both time and code
size are potentially exponential, if duplicated expressions themselves contain
macros that duplicate expressions and so on.</p><p>If you need to refer to an expression&rsquo;s value multiple times, bind it to a
temporary variable. If you need to evaluate the same expression multiple times,
then bind a temporary variable to a thunk containing the expression and then
apply the thunk multiple times.</p><p>One exception to this rule is if the macro knows that the expression is
&ldquo;simple&rdquo;, like a variable reference or quoted constant, because the macro is
private and all of its use sites can be inspected. We&rsquo;ll discuss this case in
<a href="defshape.html#%28part._simple-expr%29" data-pltdoc="x">Helper Macros and Simple Expressions</a>.</p></li><li><p>In general, a macro should evaluate expressions in the same order that
they appear (that is, &ldquo;left to right&rdquo;), unless it has a reason to do
otherwise.</p><p>In Racket information generally flows from left to right, and the interpretation
of later terms can depend on earlier terms. For example, <span class="RktSym">my-when</span> uses
the value of its first (that is, left-most) expression argument to decide
whether to evaluate its second (that is, right-most) expression. It would be
non-idiomatic syntax design to put the condition expression second and the
result expression first.</p><p>Similarly, the scope of an identifier is generally somewhere to the right of the
identifier itself. For example, in <span class="RktSym">my-match-pair</span>, the identifiers are
in scope in the following expression. If we swapped <span class="RktSym">my-match-pair</span>&rsquo;s
expressions, so it had the shape <span class="RktCmt">(my-match-pair Expr{x,xs} x:Id xs:Id
Expr)</span>, that would not be idiomatic.</p></li></ul><p>The same principles apply to <span class="RktCmt">Body</span> terms as well.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="shapes.html" title="backward to &quot;2 Terms and Shapes&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Macros and Languages in Racket&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="compound-shapes.html" title="forward to &quot;4 Compound Shapes&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>4&nbsp;Basic Shapes</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Macros and Languages in Racket</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="prelim.html" class="tocviewlink" data-pltdoc="x">Preliminaries</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="intro.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="shapes.html" class="tocviewlink" data-pltdoc="x">Terms and Shapes</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Basic Shapes</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="compound-shapes.html" class="tocviewlink" data-pltdoc="x">Compound Shapes</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="enum-shapes.html" class="tocviewlink" data-pltdoc="x">Enumerated Shapes</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="multi-shapes.html" class="tocviewlink" data-pltdoc="x">Multi-<wbr></wbr>Term Shapes</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>4&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Basic Shapes</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">4.1&nbsp;</td><td><a href="#%28part._shape~3aexpr%29" class="tocviewlink" data-pltdoc="x">The Expr (Expression) Shape</a></td></tr><tr><td align="right">4.2&nbsp;</td><td><a href="#%28part._shape~3abody%29" class="tocviewlink" data-pltdoc="x">The Body Shape</a></td></tr><tr><td align="right">4.3&nbsp;</td><td><a href="#%28part._basic-expr%29" class="tocviewlink" data-pltdoc="x">The Id (Identifier) Shape</a></td></tr><tr><td align="right">4.4&nbsp;</td><td><a href="#%28part._expr-type%29" class="tocviewlink" data-pltdoc="x">Expressions, Types, and Contracts</a></td></tr><tr><td align="right">4.5&nbsp;</td><td><a href="#%28part._expr-ops%29" class="tocviewlink" data-pltdoc="x">Uses of Expressions</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#%28part._shape~3aexpr%29" class="tocsubseclink" data-pltdoc="x">The Expr (Expression) Shape</a></td></tr><tr><td><span class="tocsublinknumber">4.2<tt>&nbsp;</tt></span><a href="#%28part._shape~3abody%29" class="tocsubseclink" data-pltdoc="x">The Body Shape</a></td></tr><tr><td><span class="tocsublinknumber">4.3<tt>&nbsp;</tt></span><a href="#%28part._basic-expr%29" class="tocsubseclink" data-pltdoc="x">The Id (Identifier) Shape</a></td></tr><tr><td><span class="tocsublinknumber">4.4<tt>&nbsp;</tt></span><a href="#%28part._expr-type%29" class="tocsubseclink" data-pltdoc="x">Expressions, Types, and Contracts</a></td></tr><tr><td><span class="tocsublinknumber">4.5<tt>&nbsp;</tt></span><a href="#%28part._expr-ops%29" class="tocsubseclink" data-pltdoc="x">Uses of Expressions</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="shapes.html" title="backward to &quot;3 Terms and Shapes&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Macros and Languages in Racket&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="compound-shapes.html" title="forward to &quot;5 Compound Shapes&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>4<tt>&nbsp;</tt><a name="(part._basic-shapes)"></a>Basic Shapes</h3><p>This section introduces the more important basic shapes for macro design.</p><h4>4.1<tt>&nbsp;</tt><a name="(part._shape~3aexpr)"></a>The Expr (Expression) Shape</h4><p>The <span class="RktCmt">Expr</span> shape contains all terms except for keywords (like
<span class="RktPn">#:when</span>). In principle, there are ways to make keywords legal Racket
expressions (by shadowing Racket&rsquo;s <span class="RktSym"><a href="http://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._~23~25datum%29%29" class="RktStxLink" data-pltdoc="x">#%datum</a></span> binding), but pragmatically
it is useful to consider expressions and keywords disjoint, so that macros can
detect and report misuses of keyword arguments.</p><p>The <span class="RktCmt">Expr</span> shape represents the intention to interpret the term as a
Racket expression by putting it in a Racket expression context.</p><p><div class="SIntrapara">For example, let&rsquo;s implement <span class="RktSym">my-when</span>, a simple version of Racket&rsquo;s
<span class="RktSym"><a href="http://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._when%29%29" class="RktStxLink" data-pltdoc="x">when</a></span> form. It takes two expressions; the first is the condition, and
the second is the result to be evaluated only if the condition is true. Here&rsquo;s
the shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-when</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Here are some examples:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"odd!\n"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect print</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"even!\n"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect no print</span></td></tr></table></blockquote></div><div class="SIntrapara">Here&rsquo;s the implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-when</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="hspace">&nbsp;</span><span class="RktSym">result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Here we use the <span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span> syntax class to annotate pattern variables that
have the <span class="RktCmt">Expr</span> shape. Note that the name of the pattern variable is just
<span class="RktSym">condition</span>, not <span class="RktSym">condition:expr</span>, so that&rsquo;s what appears in the
template.</div></p><p><div class="SIntrapara">The <span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span> annotations cause the macro to automatically report a good
error for misuses of <span class="RktSym">my-when</span> like this:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">#:truth</span><span class="hspace">&nbsp;</span><span class="RktVal">"verity"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">eval:3:0: my-when: expected expression</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">at: #:truth</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">in: (my-when #:truth "verity")</span></p></td></tr></table></blockquote></div><div class="SIntrapara">Try removing the annotations and see what the macro does on the bad example.</div></p><p><div class="SIntrapara">Here are the previous examples rephrased as tests:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"odd!\n"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">"odd!\n"</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"even!\n"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">""</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-exn%29%29" class="RktValLink" data-pltdoc="x">check-exn</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._exn~3afail~3asyntax~3f%29%29" class="RktValLink" data-pltdoc="x">exn:fail:syntax?</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/syntax/macro-testing.html#%28form._%28%28lib._syntax%2Fmacro-testing..rkt%29._convert-syntax-error%29%29" class="RktStxLink" data-pltdoc="x">convert-syntax-error</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">#:truth</span><span class="hspace">&nbsp;</span><span class="RktVal">"verity"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote></div></p><blockquote class="SubFlow"><p><a name="(exercise._basic~3amy-unless)"></a><span style="font-weight: bold">Exercise&#160;1: </span>Design a macro <span class="RktSym">my-unless</span> like
<span class="RktSym">my-when</span>, except that it negates the condition.</p></blockquote><blockquote class="SubFlow"><p><a name="(exercise._basic~3acatch-output)"></a><span style="font-weight: bold">Exercise&#160;2: </span>Design a macro <span class="RktSym">catch-output</span> that
takes a single expression argument. The expression is evaluated, but its result
is ignored; instead, the result of the macro is a string containing all of the
output written by the expression. For example:</p><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">catch-output</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/for.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._for%29%29" class="RktStxLink" data-pltdoc="x">for</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">i</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"~s"</span><span class="hspace">&nbsp;</span><span class="RktSym">i</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect "0123456789"</span></p></blockquote></blockquote><h4>4.2<tt>&nbsp;</tt><a name="(part._shape~3abody)"></a>The Body Shape</h4><p>The <span class="RktCmt">Body</span> shape is like <span class="RktCmt">Expr</span> &#8212;<wbr></wbr> it contains all terms except
keywords &#8212;<wbr></wbr> except that it indicates that the term will be used in a body
context, so definitions are allowed in addition to expressions.</p><p>There is no distinct syntax class for <span class="RktCmt">Body</span>; just use <span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span>.</p><p>In practice, the <span class="RktCmt">Body</span> shape is used with ellipses; see
<a href="compound-shapes.html" data-pltdoc="x">Compound Shapes</a>. But we can make a version of <span class="RktSym">my-when</span> that
takes a single <span class="RktCmt">Body</span> term, even though it isn&rsquo;t idiomatic Racket
syntax. Here is the shape:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-when</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Body)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote><p><div class="SIntrapara">Here is an example allowed by the new shape but not by the previous shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">37</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin%29%29" class="RktStxLink" data-pltdoc="x">begin</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">q</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._quotient%29%29" class="RktValLink" data-pltdoc="x">quotient</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"q = ~s\n"</span><span class="hspace">&nbsp;</span><span class="RktSym">q</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Given the new shape, the previous implementation would be <span class="emph">wrong</span>, since it
does not place its second argument in a body context. Here is an updated
implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-when</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result-body:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">result-body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><h4>4.3<tt>&nbsp;</tt><a name="(part._basic-expr)"></a>The Id (Identifier) Shape</h4><p>The <span class="RktCmt">Id</span> shape contains all identifiers.</p><p>The <span class="RktCmt">Id</span> shape usually implies that the identifier will be used as the
binder for a variable, macro, or other sort of name.</p><p>Use the <span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._id%29%29" class="RktStxLink" data-pltdoc="x">id</a></span> syntax class for pattern variables whose shape is <span class="RktCmt">Id</span>.</p><p>Let&rsquo;s write a macro <span class="RktSym">my-and-let</span> that acts like <span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._and%29%29" class="RktStxLink" data-pltdoc="x">and</a></span> with two
expressions but binds the result of the first expression to the given identifier
before evaluating the second expression. Here is the shape:</p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-and-let</span><span class="hspace">&nbsp;</span><span class="RktCmt">Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">For example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">a</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">c</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-and-let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._assoc%29%29" class="RktValLink" data-pltdoc="x">assoc</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect 2</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-and-let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._assoc%29%29" class="RktValLink" data-pltdoc="x">assoc</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">z</span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect #f</span></td></tr></table></blockquote></div><div class="SIntrapara">Here is an implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-and-let</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">e1:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">e2:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e1</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e2</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">The main point of <span class="RktSym">my-and-let</span>, though, is that if the second expression
is evaluated, it is evaluated in an environment where the identifier is bound to
the value of the first expression. Let&rsquo;s put that information in the shape of
<span class="RktSym">my-and-let</span>. It requires two changes:
</div><div class="SIntrapara"><ul><li><p>Label the identifier so we can refer to it later. So instead of
<span class="RktCmt">Id</span>, we write <span class="RktCmt">x:Id</span>. The label does not have to be the same as
the name of the pattern variable, but it makes sense to use the same name here.</p></li><li><p>Add an <span class="emph">environment annotation</span> to the second <span class="RktCmt">Expr</span> indicating
that it&rsquo;s in the scope of a variable whose name is whatever actual identifier
<span class="RktSym">x</span> refers to: <span class="RktCmt">Expr{x}</span>.</p></li></ul></div></p><p><div class="SIntrapara">Here&rsquo;s the updated shape for <span class="RktSym">my-and-let</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-and-let</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x})</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>We can check the implementation: <span class="RktSym">e1</span> does not occur in the scope of
<span class="RktSym">x</span>, and <span class="RktSym">e2</span> does occur in the scope of <span class="RktSym">x</span>. Consider the
following definition:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-and-let x:Id Expr Expr{x}) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-and-let</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">e1:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">e2:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e1</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">BAD</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e2</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>This implementation is <span class="emph">bad</span> because <span class="RktSym">e1</span> occurs in the scope of
<span class="RktSym">x</span>, even though it isn&rsquo;t supposed to. Here&rsquo;s another version:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-and-let x:Id Expr Expr{x}) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-and-let</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">e1:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">e2:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktSym">e1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>This implementation is good (although more complicated than unnecessary),
because <span class="RktSym">e1</span> no longer occurs in the scope of <span class="RktSym">x</span>. But what about
<span class="RktSym">tmp</span>? Because of hygiene, the definition of <span class="RktSym">tmp</span> introduced by
the macro is not visible to <span class="RktSym">e1</span>. (To be clear, it would be <span class="emph">wrong</span>
to write <span class="RktCmt">Expr{tmp}</span> for the shape of the first expression.)</p><p><span style="font-weight: bold">FIXME: explain this half of hygiene!</span></p><blockquote class="SubFlow"><p><div class="SIntrapara"><a name="(exercise._basic~3aif-let)"></a><span style="font-weight: bold">Exercise&#160;3: </span>Generalize <span class="RktSym">my-and-let</span> to
<span class="RktSym">my-if-let</span>, which takes an extra expression argument which is the
macro&rsquo;s result if the condition is false. The macro should have the following
shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-if-let</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x}</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Double-check your solution to make sure it follows the scoping specified by the
shape.</div></p></blockquote><h4>4.4<tt>&nbsp;</tt><a name="(part._expr-type)"></a>Expressions, Types, and Contracts</h4><p><div class="SIntrapara">Let&rsquo;s design the macro <span class="RktSym">my-match-pair</span>, which takes an expression to
destructure, two identifiers to bind as variables, and a result expression. Here
are some examples:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">ns</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3c%29%29" class="RktValLink" data-pltdoc="x">&lt;</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ns</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect #t</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">p</span><span class="hspace">&nbsp;</span><span class="RktVal">"hello world"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">tag</span><span class="hspace">&nbsp;</span><span class="RktSym">content</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._format%29%29" class="RktValLink" data-pltdoc="x">format</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"&lt;~a&gt;~a&lt;/~a&gt;"</span><span class="hspace">&nbsp;</span><span class="RktSym">tag</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">string-join</span><span class="hspace">&nbsp;</span><span class="RktSym">content</span><span class="hspace">&nbsp;</span><span class="RktVal">" "</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">tag</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect "&lt;p&gt;hello world&lt;/p&gt;"</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here is one shape we could write for <span class="RktSym">my-match-pair</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">xs:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x,xs})</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here&rsquo;s an implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-match-pair</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">xs:id</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">pair-v</span><span class="hspace">&nbsp;</span><span class="RktSym">pair</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">xs</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Note that we introduce a <span class="RktSym">pair-v</span> variable to avoid evaluating the
<span class="RktSym">pair</span> expression twice.</div></p><p><div class="SIntrapara">We could add more information to the shape. The macro expects the first argument
to be a pair, and whatever types of values the pair contains become the types of
the identifiers:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr[(cons</span><span class="hspace">&nbsp;</span><span class="RktCmt">T1</span><span class="hspace">&nbsp;</span><span class="RktCmt">T2)]</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">xs:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x:T1,xs:T2})</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">I&rsquo;ve written <span class="RktCmt">Expr[(cons T1 T2)]</span> for the shape of expressions of type
<span class="RktCmt">(cons T1 T2)</span>, where the type <span class="RktCmt">(cons T1 T2)</span> is the type of all pairs
(values made with the <span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span> constructor) whose first component has type
<span class="RktCmt">T1</span> and whose second component has type <span class="RktCmt">T2</span>. The second expression&rsquo;s
environment annotation includes the types of the variables. This macro shape is
polymorphic; you can imagine an implicit <span class="RktCmt">forall (T1, T2)</span> at the
beginning of the declaration.</div></p><p><div class="SIntrapara">The result of the macro is the result of the second expression, so the type of
the macro is the same as the type of the second expression. We could add that
to the shape too:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr[(cons</span><span class="hspace">&nbsp;</span><span class="RktCmt">T1</span><span class="hspace">&nbsp;</span><span class="RktCmt">T2)]</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">xs:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x:T1,xs:T2}[R])</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr[R]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Now the second <span class="RktCmt">Expr</span> has both a environment annotation and a type
annotation.</div></p><p>Note: When I say &ldquo;type&rdquo; here, I&rsquo;m not talking about Typed Racket or some other
typed language implemented in Racket. Nor do I mean that there&rsquo;s a super-secret
type checker hidden in Racket on the top shelf next to the flight simulator. I&rsquo;m
using &ldquo;type&rdquo; to mean a semi-formal, unchecked description of the behavior of
expressions and macros that manipulate them. In this case, the shape declaration
for <span class="RktSym">my-match-pair</span> warns the user that the first argument must produce a
pair. If it doesn&rsquo;t, the user has failed their obligations, and the macro may do
bad things.</p><p>Of course, given human limitations, we would prefer the macro not to do bad
things. Ideally, the macro definition and macro uses could be statically checked
for compliance with shape declarations, but Racket does not not implement such a
checker for macros. (It&rsquo;s complicated.) At least, though, the macro could use
<span class="emph">contracts</span> to enforce approximations of the types of expression arguments.</p><p>Use the <span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28def._%28%28lib._syntax%2Fparse..rkt%29._expr%2Fc%29%29" class="RktValLink" data-pltdoc="x">expr/c</a></span> syntax class for a pattern variable whose shape is
<span class="RktCmt">Expr[Type]</span> when <span class="RktCmt">Type</span> has a useful contract approximation. In this
example, the type <span class="RktCmt">(cons T1 T2)</span> has a useful contract approximation
<span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span>, but there is no useful contract for the type <span class="RktCmt">R</span>. The
<span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28def._%28%28lib._syntax%2Fparse..rkt%29._expr%2Fc%29%29" class="RktValLink" data-pltdoc="x">expr/c</a></span> syntax class takes an argument, so you cannot use the
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">:</span><span class="hspace"></span></span> notation; you must use <span class="RktSym"><a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7evar%29%29" class="RktStxLink" data-pltdoc="x">~var</a></span> or <span class="RktPn">#:declare</span>
instead. The argument is a syntax object representing the contract to apply to
the expression. (It is <span class="RktRdr">#'</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span> instead of <span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span> because the
contract check is performed at run time.) Finally, use the <span class="RktSym">c</span>
("contracted") <span class="emph">attribute</span> of the pattern variable to get the
contract-wrapped version of the expression. Here&rsquo;s the contract-checked version
of the macro:</p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-match-pair Expr[(cons T1 T2)] x:Id xs:Id Expr{x:T1,xs:T2}[R]) : Expr[R]</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-match-pair</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7evar%29%29" class="RktStxLink" data-pltdoc="x">~var</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28def._%28%28lib._syntax%2Fparse..rkt%29._expr%2Fc%29%29" class="RktValLink" data-pltdoc="x">expr/c</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">xs:id</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">pair-v</span><span class="hspace">&nbsp;</span><span class="RktSym">pair.c</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">xs</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Here&rsquo;s the implementation using <span class="RktPn">#:declare</span> instead of <span class="RktSym"><a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7evar%29%29" class="RktStxLink" data-pltdoc="x">~var</a></span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-match-pair</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair</span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">xs:id</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:declare</span><span class="hspace">&nbsp;</span><span class="RktSym">pair</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28def._%28%28lib._syntax%2Fparse..rkt%29._expr%2Fc%29%29" class="RktValLink" data-pltdoc="x">expr/c</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">pair-v</span><span class="hspace">&nbsp;</span><span class="RktSym">pair.c</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">xs</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Now calling <span class="RktSym">my-match-pair</span> raises a contract violation if the first
expression does not produce a pair:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">not-a-pair</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">ns</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">my-match-pair: contract violation</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: pair?</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">given: 'not-a-pair</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">in: pair?</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">macro argument contract</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">contract from: top-level</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">blaming: top-level</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">(assuming the contract is correct)</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">at: eval:13:0</span></p></td></tr></table></blockquote></div></p><blockquote class="SubFlow"><p><a name="(exercise._basic~3amy-when-contract)"></a><span style="font-weight: bold">Exercise&#160;4: </span>Modify the <span class="RktSym">my-when</span> macro to
check that the condition expression produces a boolean value. (Note: this is not
idiomatic for Racket conditional macros).</p></blockquote><h4>4.5<tt>&nbsp;</tt><a name="(part._expr-ops)"></a>Uses of Expressions</h4><p><div class="SIntrapara">What can a macro do with an expression (<span class="RktCmt">Expr</span>)?
</div><div class="SIntrapara"><ul><li><p>It can use the value (or values) that the expression evaluates to. For
example, the behavior of the <span class="RktSym">my-when</span> macro depends on the value that
its first expression produces.</p></li><li><p>It can determine whether the expression is evaluated or when the
expression is evaluated. The <span class="RktSym">my-when</span> example determines whether to
evaluate its second expression. The standard <span class="RktSym">delay</span> macro is a classic
example of controlling when an expression is evaluated.</p></li><li><p>It can change what dynamic context the expression is evaluated within. For
example, a macro could use <span class="RktSym"><a href="http://docs.racket-lang.org/reference/parameters.html#%28form._%28%28lib._racket%2Fprivate%2Fmore-scheme..rkt%29._parameterize%29%29" class="RktStxLink" data-pltdoc="x">parameterize</a></span> to evaluate the expression in a
context with different values for some parameters.</p></li><li><p>It can change the static context the expression is evaluated
within. Mainly, this means putting the expression in the scope of additional
bindings, as we did in <span class="RktSym">my-and-let</span> and <span class="RktSym">my-match-pair</span>.</p></li></ul></div></p><p>There are also some restrictions on what macros can do with expressions:</p><ul><li><p><span style="font-weight: bold">A macro must not look at the contents of the expression itself.</span>
Expressions are macro-extensible, so there is no grammar to guide case
analysis. Interpreting expressions is the macro expander&rsquo;s business, so don&rsquo;t
try it yourself. The macro expander is complicated, and if you attempt to
duplicate its work &ldquo;just a little&rdquo;, you are likely to make unjustified
assumptions and get it wrong. For example, an expression consisting of a
self-quoting datum is not necessarily a constant, or even free of side effects;
it might have a nonstandard <span class="RktSym"><a href="http://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._~23~25datum%29%29" class="RktStxLink" data-pltdoc="x">#%datum</a></span> binding, which could give it any
behavior at all. Likewise, a single identifier is not necessarily a variable
reference; it might be an identifier macro, or it might have a nonstandard
<span class="RktSym"><a href="http://docs.racket-lang.org/reference/__top.html#%28form._%28%28quote._~23~25kernel%29._~23~25top%29%29" class="RktStxLink" data-pltdoc="x">#%top</a></span> binding.</p><p>In later sections (FIXME-REF), we&rsquo;ll talk about how to cooperate with
the macro expander to do case analysis of expressions and other forms.</p></li><li><p>In general, a macro should not duplicate an argument expression. That is,
the expression should occur exactly once in the macro&rsquo;s expansion. Duplicating
expressions leads to expanding the same code multiple times, which can lead to
slow compilation and bloated compiled code. The increases to both time and code
size are potentially exponential, if duplicated expressions themselves contain
macros that duplicate expressions and so on.</p><p>If you want to evaluate the same expression multiple times, then thunk it and
bind a temporary variable to the thunk and then use the variable to apply the
thunk multiple times.</p><p>One exception to this rule is if the macro knows that the expression is
&ldquo;simple&rdquo;, like a variable reference or a quoted constant. For example, when a
public macro binds a temporary variable to an argument expression and then calls
a private helper macro with the temporary variable, the helper macro can
duplicate the variable reference freely. Note that in this example, the private
macro must know that the public macro gives it a simple expression; it cannot
check whether an expression of unknown origin is simple (see the previous
restriction).</p></li><li><p>In general, a macro should evaluate expressions in the same order that
they appear (that is, &ldquo;left to right&rdquo;), unless it has a reason to do
otherwise.</p><p>In Racket information generally flows from left to right, and the interpretation
of later terms can depend on earlier terms. For example, <span class="RktSym">my-when</span> uses
the value of its first (that is, left-most) expression argument to decide
whether to evaluate its second (that is, right-most) expression. It would be
non-idiomatic syntax design to put the condition expression second and the
result expression first.</p><p>Similarly, the scope of an identifier is generally somewhere to the right of the
identifier itself. For example, in both <span class="RktSym">my-and-let</span> and
<span class="RktSym">my-match-pair</span>, the identifiers are in scope in the following
expression. If we swapped <span class="RktSym">my-match-pair</span>&rsquo;s expressions, so it had the
shape <span class="RktCmt">(my-match-pair Expr{x,xs} x:Id xs:Id Expr)</span>, that would be peculiar.</p></li></ul><p>The same principles apply to <span class="RktCmt">Body</span> terms as well.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="shapes.html" title="backward to &quot;3 Terms and Shapes&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Macros and Languages in Racket&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="compound-shapes.html" title="forward to &quot;5 Compound Shapes&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
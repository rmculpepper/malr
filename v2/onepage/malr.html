<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Macros and Languages in Racket</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Macros and Languages in Racket</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._intro%29" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._shapes%29" class="tocviewlink" data-pltdoc="x">Terms and Shapes</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._basic-shapes%29" class="tocviewlink" data-pltdoc="x">Basic Shapes</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._compound-shapes%29" class="tocviewlink" data-pltdoc="x">Compound Shapes</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._defshape%29" class="tocviewlink" data-pltdoc="x">Shape Definitions</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._enum-shapes%29" class="tocviewlink" data-pltdoc="x">Enumerated Shapes</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="#%28part._multi-shapes%29" class="tocviewlink" data-pltdoc="x">Multi-<wbr></wbr>Term Shapes</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="#%28part._rec-shapes%29" class="tocviewlink" data-pltdoc="x">Recursive Shapes</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Macros_and_.Languages_in_.Racket%29" class="tocsubseclink" data-pltdoc="x">Macros and Languages in Racket</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._intro%29" class="tocsubseclink" data-pltdoc="x">Introduction</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._htdm%29" class="tocsubseclink" data-pltdoc="x">How to Design Macros</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._first%29" class="tocsubseclink" data-pltdoc="x">Designing Your First Macro</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._intro-order%29" class="tocsubseclink" data-pltdoc="x">Expansion Contexts and Expansion Order</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#%28part._intro-lexical%29" class="tocsubseclink" data-pltdoc="x">Proper Lexical Scoping</a></td></tr><tr><td><span class="tocsublinknumber">1.5<tt>&nbsp;</tt></span><a href="#%28part._intro-impl%29" class="tocsubseclink" data-pltdoc="x">More Implementations of <span class="RktSym">assert</span></a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._shapes%29" class="tocsubseclink" data-pltdoc="x">Terms and Shapes</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._shapes-terms%29" class="tocsubseclink" data-pltdoc="x">Terms</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._shapes-interps%29" class="tocsubseclink" data-pltdoc="x">Interpretations of Terms</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._shapes-shapes%29" class="tocsubseclink" data-pltdoc="x">Shapes</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._basic-shapes%29" class="tocsubseclink" data-pltdoc="x">Basic Shapes</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._basic-expr%29" class="tocsubseclink" data-pltdoc="x">The Expr (Expression) Shape</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._basic-body%29" class="tocsubseclink" data-pltdoc="x">The Body Shape</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._basic-hygiene2%29" class="tocsubseclink" data-pltdoc="x">Proper Lexical Scoping, Part 2</a></td></tr><tr><td><span class="tocsublinknumber">3.4<tt>&nbsp;</tt></span><a href="#%28part._basic-id%29" class="tocsubseclink" data-pltdoc="x">The Id (Identifier) Shape</a></td></tr><tr><td><span class="tocsublinknumber">3.5<tt>&nbsp;</tt></span><a href="#%28part._basic-type%29" class="tocsubseclink" data-pltdoc="x">Expressions, Types, and Contracts</a></td></tr><tr><td><span class="tocsublinknumber">3.6<tt>&nbsp;</tt></span><a href="#%28part._basic-expr-uses%29" class="tocsubseclink" data-pltdoc="x">Uses of Expressions</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._compound-shapes%29" class="tocsubseclink" data-pltdoc="x">Compound Shapes</a></td></tr><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#%28part._list-shapes%29" class="tocsubseclink" data-pltdoc="x">List Shapes</a></td></tr><tr><td><span class="tocsublinknumber">4.2<tt>&nbsp;</tt></span><a href="#%28part._ellipses-simple%29" class="tocsubseclink" data-pltdoc="x">Ellipses with Simple Shapes</a></td></tr><tr><td><span class="tocsublinknumber">4.2.1<tt>&nbsp;</tt></span><a href="#%28part._ellipses-rec-macro%29" class="tocsubseclink" data-pltdoc="x">Recursive Macros</a></td></tr><tr><td><span class="tocsublinknumber">4.2.2<tt>&nbsp;</tt></span><a href="#%28part._ellipses-rt-helper%29" class="tocsubseclink" data-pltdoc="x">Recursive Run-<wbr></wbr>time Helper Function</a></td></tr><tr><td><span class="tocsublinknumber">4.2.3<tt>&nbsp;</tt></span><a href="#%28part._ellipses-ct-helper%29" class="tocsubseclink" data-pltdoc="x">Recursive Compile-<wbr></wbr>time Helper Function</a></td></tr><tr><td><span class="tocsublinknumber">4.3<tt>&nbsp;</tt></span><a href="#%28part._ellipses-compound%29" class="tocsubseclink" data-pltdoc="x">Ellipses with Compound Shapes</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._defshape%29" class="tocsubseclink" data-pltdoc="x">Shape Definitions</a></td></tr><tr><td><span class="tocsublinknumber">5.1<tt>&nbsp;</tt></span><a href="#%28part._defshape-def%29" class="tocsubseclink" data-pltdoc="x">Defining New Shapes</a></td></tr><tr><td><span class="tocsublinknumber">5.2<tt>&nbsp;</tt></span><a href="#%28part._defshape-same-diff%29" class="tocsubseclink" data-pltdoc="x">Same Structure, Different Interpretation</a></td></tr><tr><td><span class="tocsublinknumber">5.3<tt>&nbsp;</tt></span><a href="#%28part._simple-expr%29" class="tocsubseclink" data-pltdoc="x">Helper Macros and Simple Expressions</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._enum-shapes%29" class="tocsubseclink" data-pltdoc="x">Enumerated Shapes</a></td></tr><tr><td><span class="tocsublinknumber">6.1<tt>&nbsp;</tt></span><a href="#%28part._enum-shapes-def%29" class="tocsubseclink" data-pltdoc="x">Defining Enumerated Shapes</a></td></tr><tr><td><span class="tocsublinknumber">6.1.1<tt>&nbsp;</tt></span><a href="#%28part._enum-empty%29" class="tocsubseclink" data-pltdoc="x">Empty Interface Strategy (Redo Case Analysis)</a></td></tr><tr><td><span class="tocsublinknumber">6.1.2<tt>&nbsp;</tt></span><a href="#%28part._enum-meaning%29" class="tocsubseclink" data-pltdoc="x">Common Meaning Interface Strategy</a></td></tr><tr><td><span class="tocsublinknumber">6.1.3<tt>&nbsp;</tt></span><a href="#%28part._enum-behavior%29" class="tocsubseclink" data-pltdoc="x">Macro Behavior Interface Strategy</a></td></tr><tr><td><span class="tocsublinknumber">6.1.4<tt>&nbsp;</tt></span><a href="#%28part._enum-codegen%29" class="tocsubseclink" data-pltdoc="x">Code Generator Interface Strategy</a></td></tr><tr><td><span class="tocsublinknumber">6.1.5<tt>&nbsp;</tt></span><a href="#%28part._enum-ast%29" class="tocsubseclink" data-pltdoc="x">AST Interface Strategy</a></td></tr><tr><td><span class="tocsublinknumber">6.2<tt>&nbsp;</tt></span><a href="#%28part._enum-overlap%29" class="tocsubseclink" data-pltdoc="x">Designing Enumerated Syntax</a></td></tr><tr><td><span class="tocsublinknumber">7<tt>&nbsp;</tt></span><a href="#%28part._multi-shapes%29" class="tocsubseclink" data-pltdoc="x">Multi-<wbr></wbr>Term Shapes</a></td></tr><tr><td><span class="tocsublinknumber">7.1<tt>&nbsp;</tt></span><a href="#%28part._multi-terms%29" class="tocsubseclink" data-pltdoc="x">Shapes for Multiple Terms</a></td></tr><tr><td><span class="tocsublinknumber">7.1.1<tt>&nbsp;</tt></span><a href="#%28part._multi-redo-case%29" class="tocsubseclink" data-pltdoc="x">Redo Case Analysis</a></td></tr><tr><td><span class="tocsublinknumber">7.1.2<tt>&nbsp;</tt></span><a href="#%28part._multi-codegen%29" class="tocsubseclink" data-pltdoc="x">Code Generator</a></td></tr><tr><td><span class="tocsublinknumber">7.1.3<tt>&nbsp;</tt></span><a href="#%28part._multi-ast%29" class="tocsubseclink" data-pltdoc="x">AST</a></td></tr><tr><td><span class="tocsublinknumber">7.2<tt>&nbsp;</tt></span><a href="#%28part._optional-shapes%29" class="tocsubseclink" data-pltdoc="x">Optional Shapes</a></td></tr><tr><td><span class="tocsublinknumber">7.3<tt>&nbsp;</tt></span><a href="#%28part._shapes-types-scopes%29" class="tocsubseclink" data-pltdoc="x">Shapes, Types, and Scopes (&#9733;)</a></td></tr><tr><td><span class="tocsublinknumber">8<tt>&nbsp;</tt></span><a href="#%28part._rec-shapes%29" class="tocsubseclink" data-pltdoc="x">Recursive Shapes</a></td></tr><tr><td><span class="tocsublinknumber">8.1<tt>&nbsp;</tt></span><a href="#%28part._datum-shape%29" class="tocsubseclink" data-pltdoc="x">The Datum Shape</a></td></tr><tr><td><span class="tocsublinknumber">8.2<tt>&nbsp;</tt></span><a href="#%28part._rec-datum%29" class="tocsubseclink" data-pltdoc="x">Datum as a Recursive Shape</a></td></tr><tr><td><span class="tocsublinknumber">8.3<tt>&nbsp;</tt></span><a href="#%28part._quasiquote%29" class="tocsubseclink" data-pltdoc="x">Quasiquotation</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">2-0519.15</span></div><h2><a name="(part._.Macros_and_.Languages_in_.Racket)"></a>Macros and Languages in Racket</h2><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Ryan Culpepper &lt;<a href="mailto:ryanc@racket-lang.org">ryanc@racket-lang.org</a>&gt;</p></span></div><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._intro%29" class="toptoclink" data-pltdoc="x">1<span class="hspace">&nbsp;</span>Introduction</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._htdm%29" class="toclink" data-pltdoc="x">1.1<span class="hspace">&nbsp;</span>How to Design Macros</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._first%29" class="toclink" data-pltdoc="x">1.2<span class="hspace">&nbsp;</span>Designing Your First Macro</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._intro-order%29" class="toclink" data-pltdoc="x">1.3<span class="hspace">&nbsp;</span>Expansion Contexts and Expansion Order</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._intro-lexical%29" class="toclink" data-pltdoc="x">1.4<span class="hspace">&nbsp;</span>Proper Lexical Scoping</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._intro-impl%29" class="toclink" data-pltdoc="x">1.5<span class="hspace">&nbsp;</span>More Implementations of <span class="RktSym">assert</span></a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._shapes%29" class="toptoclink" data-pltdoc="x">2<span class="hspace">&nbsp;</span>Terms and Shapes</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._shapes-terms%29" class="toclink" data-pltdoc="x">2.1<span class="hspace">&nbsp;</span>Terms</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._shapes-interps%29" class="toclink" data-pltdoc="x">2.2<span class="hspace">&nbsp;</span>Interpretations of Terms</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._shapes-shapes%29" class="toclink" data-pltdoc="x">2.3<span class="hspace">&nbsp;</span>Shapes</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._basic-shapes%29" class="toptoclink" data-pltdoc="x">3<span class="hspace">&nbsp;</span>Basic Shapes</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._basic-expr%29" class="toclink" data-pltdoc="x">3.1<span class="hspace">&nbsp;</span>The Expr (Expression) Shape</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._basic-body%29" class="toclink" data-pltdoc="x">3.2<span class="hspace">&nbsp;</span>The Body Shape</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._basic-hygiene2%29" class="toclink" data-pltdoc="x">3.3<span class="hspace">&nbsp;</span>Proper Lexical Scoping, Part 2</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._basic-id%29" class="toclink" data-pltdoc="x">3.4<span class="hspace">&nbsp;</span>The Id (Identifier) Shape</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._basic-type%29" class="toclink" data-pltdoc="x">3.5<span class="hspace">&nbsp;</span>Expressions, Types, and Contracts</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._basic-expr-uses%29" class="toclink" data-pltdoc="x">3.6<span class="hspace">&nbsp;</span>Uses of Expressions</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._compound-shapes%29" class="toptoclink" data-pltdoc="x">4<span class="hspace">&nbsp;</span>Compound Shapes</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._list-shapes%29" class="toclink" data-pltdoc="x">4.1<span class="hspace">&nbsp;</span>List Shapes</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._ellipses-simple%29" class="toclink" data-pltdoc="x">4.2<span class="hspace">&nbsp;</span>Ellipses with Simple Shapes</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._ellipses-rec-macro%29" class="toclink" data-pltdoc="x">4.2.1<span class="hspace">&nbsp;</span>Recursive Macros</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._ellipses-rt-helper%29" class="toclink" data-pltdoc="x">4.2.2<span class="hspace">&nbsp;</span>Recursive Run-time Helper Function</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._ellipses-ct-helper%29" class="toclink" data-pltdoc="x">4.2.3<span class="hspace">&nbsp;</span>Recursive Compile-time Helper Function</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._ellipses-compound%29" class="toclink" data-pltdoc="x">4.3<span class="hspace">&nbsp;</span>Ellipses with Compound Shapes</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._defshape%29" class="toptoclink" data-pltdoc="x">5<span class="hspace">&nbsp;</span>Shape Definitions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._defshape-def%29" class="toclink" data-pltdoc="x">5.1<span class="hspace">&nbsp;</span>Defining New Shapes</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._defshape-same-diff%29" class="toclink" data-pltdoc="x">5.2<span class="hspace">&nbsp;</span>Same Structure, Different Interpretation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._simple-expr%29" class="toclink" data-pltdoc="x">5.3<span class="hspace">&nbsp;</span>Helper Macros and Simple Expressions</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._enum-shapes%29" class="toptoclink" data-pltdoc="x">6<span class="hspace">&nbsp;</span>Enumerated Shapes</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._enum-shapes-def%29" class="toclink" data-pltdoc="x">6.1<span class="hspace">&nbsp;</span>Defining Enumerated Shapes</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._enum-empty%29" class="toclink" data-pltdoc="x">6.1.1<span class="hspace">&nbsp;</span>Empty Interface Strategy (Redo Case Analysis)</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._enum-meaning%29" class="toclink" data-pltdoc="x">6.1.2<span class="hspace">&nbsp;</span>Common Meaning Interface Strategy</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._enum-behavior%29" class="toclink" data-pltdoc="x">6.1.3<span class="hspace">&nbsp;</span>Macro Behavior Interface Strategy</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._enum-codegen%29" class="toclink" data-pltdoc="x">6.1.4<span class="hspace">&nbsp;</span>Code Generator Interface Strategy</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._enum-ast%29" class="toclink" data-pltdoc="x">6.1.5<span class="hspace">&nbsp;</span>AST Interface Strategy</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._enum-overlap%29" class="toclink" data-pltdoc="x">6.2<span class="hspace">&nbsp;</span>Designing Enumerated Syntax</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._multi-shapes%29" class="toptoclink" data-pltdoc="x">7<span class="hspace">&nbsp;</span>Multi-Term Shapes</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._multi-terms%29" class="toclink" data-pltdoc="x">7.1<span class="hspace">&nbsp;</span>Shapes for Multiple Terms</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._multi-redo-case%29" class="toclink" data-pltdoc="x">7.1.1<span class="hspace">&nbsp;</span>Redo Case Analysis</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._multi-codegen%29" class="toclink" data-pltdoc="x">7.1.2<span class="hspace">&nbsp;</span>Code Generator</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._multi-ast%29" class="toclink" data-pltdoc="x">7.1.3<span class="hspace">&nbsp;</span>AST</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._optional-shapes%29" class="toclink" data-pltdoc="x">7.2<span class="hspace">&nbsp;</span>Optional Shapes</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._shapes-types-scopes%29" class="toclink" data-pltdoc="x">7.3<span class="hspace">&nbsp;</span>Shapes, Types, and Scopes (&#9733;)</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._rec-shapes%29" class="toptoclink" data-pltdoc="x">8<span class="hspace">&nbsp;</span>Recursive Shapes</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._datum-shape%29" class="toclink" data-pltdoc="x">8.1<span class="hspace">&nbsp;</span>The Datum Shape</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._rec-datum%29" class="toclink" data-pltdoc="x">8.2<span class="hspace">&nbsp;</span>Datum as a Recursive Shape</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._quasiquote%29" class="toclink" data-pltdoc="x">8.3<span class="hspace">&nbsp;</span>Quasiquotation</a></p></td></tr></table><p style="padding: 4em 0"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="license"><img src="by-nc-nd-4.0-80x15.png" alt="Creative Commons License" width="80" height="15"/></a>
This work by Ryan Culpepper is licensed under a
<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="license">Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.</p><h3>1<tt>&nbsp;</tt><a name="(part._intro)"></a>Introduction</h3><p>This section introduces the elements of macro design and illustrates these
design elements with simple example macro. It uses the example to introduce some
of Racket&rsquo;s facilities for specifying, implementing, and testing macros.</p><p>This guide assumes that you have a basic working knowledge of Racket and
functional programming. <a href="https://docs.racket-lang.org/guide/index.html" data-pltdoc="x">The Racket Guide</a> is
sufficient for the former, and <a href="https://htdp.org/"><span style="font-style: italic">HtDP</span></a> is good for the latter.</p><h4>1.1<tt>&nbsp;</tt><a name="(part._htdm)"></a>How to Design Macros</h4><p>This guide is an attempt to adapt the ideas of <span style="font-style: italic"><a href="https://htdp.org/">How to Design Programs</a> (HtDP)</span> to the design of
macros and languages in Racket. The central idea of <span style="font-style: italic">HtDP</span> is the &ldquo;design
recipe&rdquo;; the kernel of the design recipe consists of the following four steps:</p><ul><li><p>Specify the inputs.</p></li><li><p>Write examples that can be turned into tests.</p></li><li><p>Choose an implementation strategy.</p></li><li><p>Finish the implementation and check it.</p></li></ul><p><span style="font-style: italic">HtDP</span> instantiates this kernel to teach the foundations of
programming. Its specification language is a semiformal language of types
including set-based reasoning and parametric polymorphism. Its implementation
strategies include structural recursion and case analysis following data type
definitions. It instantiates the implementation language to a series of simple
Scheme-like functional programming languages, and it provides a testing
framework.</p><p>Along the way, <span style="font-style: italic">HtDP</span> fills in the design recipe&rsquo;s skeleton with idioms,
tricks, preferences, and limitations of Scheme-like (and ML-like)
mostly-functional programming languages. For example, it demonstrates
abstraction via parametric polymorphism and higher-order functions rather than
OO patterns. To name some of the limitations: it uses lexical scoping; it avoids
reflection (eg, no accessing structure fields by strings); it avoids
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29" class="RktValLink" data-pltdoc="x">eval</a></span>; it treats closures as opaque; it (usually) avoids mutation; and
so on. Once you absorb them, these parts of the programming mental model tend to
be invisible, until you compare with a language that makes different choices.</p><p>This guide instantiates the design recipe kernel as follows: It introduces a
specification language called <span class="emph">shapes</span>, combining features of grammars,
patterns, and types. The implementation strategies are more specialized, but
they are still organized around the shapes of macro inputs. The implementation
language is Racket with <a href="https://docs.racket-lang.org/syntax/stxparse.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">syntax/parse</span></a> and some other standard
syntax libraries.</p><p>Along the way, it covers some of the idioms and limitations of the programming
model for macros: macros (usually) respect lexical scoping; they must respect
the &ldquo;phase&rdquo; separation between compile time and run time; they avoid
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29" class="RktValLink" data-pltdoc="x">eval</a></span>; they (usually) treat expressions as opaque; and so on.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._first)"></a>Designing Your First Macro</h4><p>Suppose we wanted a feature, <span class="RktSym">assert</span>, that takes an expression and
evaluates it, raising an error that includes the expression text if it does not
evaluate to a true value. The result of the <span class="RktSym">assert</span> expression itself is
<span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span>.</p><p>Clearly, <span class="RktSym">assert</span> cannot be a function, because a function cannot access
the text of its arguments. It must be a macro.</p><p><div class="SIntrapara">We can specify the <span class="emph">shape</span> of <span class="RktSym">assert</span> as follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(assert</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">That is, the <span class="RktSym">assert</span> macro takes a single argument, an expression, and a
use of the <span class="RktSym">assert</span> macro is an expression.</div></p><p>Here are some examples that illustrate the intended behavior of <span class="RktSym">assert</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">assert</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3e%29%29" class="RktValLink" data-pltdoc="x">&gt;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">assert</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">assert: assertion failed: (even? (length ls))</span></p></td></tr></table></blockquote><p><div class="SIntrapara">In addition to considering the macro&rsquo;s behavior, it can be useful to consider
what code could be used to implement an example use of the macro. The second
example, for instance, could be implemented by the following code:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: (even? (length ls))"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">It would be a bit complicated (although possible) for our <span class="RktSym">assert</span> macro
to produce this exact code, because it incorporates the argument expression into
a string literal. But there&rsquo;s no need to produce that string literal at compile
time. Here is an equivalent bit of code that produces the same string at run
time instead, with the help of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> and <span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span>&rsquo;s built-in
formatting capabilities:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: ~s"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><blockquote class="SubFlow"><p><span style="font-weight: bold">Lesson: </span><span style="font-style: italic">Don&rsquo;t fixate on the exact code you first write down for the
macro&rsquo;s example expansion. Often, you can change it slightly to make
it easier for the macro to produce.</span></p></blockquote><blockquote class="SubFlow"><p><span style="font-weight: bold">Lesson: </span><span style="font-style: italic">It&rsquo;s often simpler to produce an expression that does a
computation at run time than to do the computation at compile time.</span></p></blockquote><p><div class="SIntrapara">That&rsquo;s our implementation strategy for the <span class="RktSym">assert</span> macro: we will simply
use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span>, <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span>, and <span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span>. In general, the macro
performs the following transformation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">assert</span><span class="hspace">&nbsp;</span><span class="RktVar">condition</span><span class="RktPn">)</span></td></tr><tr><td>&#8658;</td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktVar">condition</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: ~s"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktVar">condition</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Before we define the macro, we must import the machinery we&rsquo;ll use in its
implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._for-syntax%29%29" class="RktStxLink" data-pltdoc="x">for-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">racket/base</span><span class="hspace">&nbsp;</span><span class="RktSym">syntax/parse</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></div><div class="SIntrapara">The <span class="RktSym"><a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._for-syntax%29%29" class="RktStxLink" data-pltdoc="x">for-syntax</a></span> modifier indicates that we need these imports to perform
<span class="emph">compile-time</span> computation &#8212;<wbr></wbr> a macro is implemented by a compile-time
function from syntax to syntax. We need <a href="https://docs.racket-lang.org/reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">racket/base</span></a> for syntax
templates. We need <a href="https://docs.racket-lang.org/syntax/stxparse.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">syntax/parse</span></a> for <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span>,
which is a pattern-matching utility for syntax objects.</div></p><p>Here is the macro definition:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(assert Expr) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">assert</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax%29%29" class="RktStxLink" data-pltdoc="x">syntax</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: ~e"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p><div class="SIntrapara">Here is an overview of the macro definition:
</div><div class="SIntrapara"><ul><li><p>The macro is defined using <span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span>, which takes the macro&rsquo;s
name and a <span class="emph">compile-time</span> expression for the macro&rsquo;s <span class="emph">transformer</span>
function. By &ldquo;compile-time expression&rdquo;, I mean that the expression is
evaluated at compile time using the <span class="emph">compile-time environment</span>, which is
distinct from the normal environment. We initialized the compile-time
environment earlier with <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._for-syntax%29%29" class="RktStxLink" data-pltdoc="x">for-syntax</a></span><span class="stt"> </span><span class="RktSym">racket/base</span><span class="stt"> </span><span class="RktSym">syntax/parse</span><span class="RktPn">)</span><span class="RktPn">)</span>.</p></li><li><p>The transformer takes a syntax object representing the macro use and
returns a syntax object for the macro&rsquo;s expansion. This transformer is
implemented with <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span>, which takes a sequence of clauses
consisting of a <span class="emph">syntax pattern</span> and a <span class="emph">result expression</span>. This
macro&rsquo;s transformer has only one clause.</p></li><li><p>The pattern <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="stt"> </span><span class="RktSym">condition:expr</span><span class="RktPn">)</span> says that after the macro name
(typically represented by the wildcard pattern <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span>) the macro expects one
expression, representing a &ldquo;condition&rdquo;. The identifier <span class="RktSym">condition</span> is a
<span class="emph">syntax pattern variable</span>; it is <span class="emph">annotated</span> with the <span class="emph">syntax
class</span> <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span>. If the clause&rsquo;s pattern matches the macro use, then its
pattern variables are defined and available in <span class="emph">syntax templates</span> in the
clause&rsquo;s result expression.</p></li><li><p>The clause&rsquo;s result expression is a <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax%29%29" class="RktStxLink" data-pltdoc="x">syntax</a></span> expression, which
contains a <span class="emph">syntax template</span>. It is similar to <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._quasiquote%29%29" class="RktStxLink" data-pltdoc="x">quasiquote</a></span> except
that pattern variables do not need explicit <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">unquote</a></span>s. (It also
cooperates with ellipses and some other features; we&rsquo;ll talk about them later.)
When the <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax%29%29" class="RktStxLink" data-pltdoc="x">syntax</a></span> expression is evaluated, it produces a syntax object
with the pattern variables in the template replaced with the terms matched from
the macro use. Note that even the occurrence within the <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> term gets
replaced &#8212;<wbr></wbr> pattern variable substitution happens before the <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> is
interpreted, so a <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> in the template is treated like any other
identifier.</p></li></ul></div></p><p><div class="SIntrapara">Finally, we should test the macro. I&rsquo;ll use <a href="https://docs.racket-lang.org/rackunit/api.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">rackunit</span></a> for
testing:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="hspace">&nbsp;</span><span class="RktSym">rackunit</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Here <a href="https://docs.racket-lang.org/rackunit/api.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">rackunit</span></a> is required normally, not <span class="RktSym"><a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._for-syntax%29%29" class="RktStxLink" data-pltdoc="x">for-syntax</a></span>,
because I intend to use it to test the behavior of <span class="RktSym">assert</span> expressions;
I don&rsquo;t intend to test <span class="RktSym">assert</span>&rsquo;s compile-time transformer function
directly.</div></p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assert</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3e%29%29" class="RktValLink" data-pltdoc="x">&gt;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-exn%29%29" class="RktValLink" data-pltdoc="x">check-exn</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._exn~3afail~3f%29%29" class="RktValLink" data-pltdoc="x">exn:fail?</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assert</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote></div><div class="SIntrapara">What if we want to test uses of <span class="RktSym">assert</span> that might result in
compile-time exceptions, like syntax errors? The following does not work:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-exn%29%29" class="RktValLink" data-pltdoc="x">check-exn</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._exn~3afail~3asyntax~3f%29%29" class="RktValLink" data-pltdoc="x">exn:fail:syntax?</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assert</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">an-extra-argument</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktErr">eval:12:0: assert: unexpected term</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">at: (quote an-extra-argument)</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">in: (assert (odd? (length ls)) (quote an-extra-argument))</span></p></td></tr></table></blockquote></div><div class="SIntrapara">Racket expands and compiles expressions before it evaluates them. The syntax
error is detected and raised at compile time (during expansion), but
<span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-exn%29%29" class="RktValLink" data-pltdoc="x">check-exn</a></span> does not install its exception handler until run time.</div></p><p><div class="SIntrapara">One solution is to use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29" class="RktValLink" data-pltdoc="x">eval</a></span> for this test. This is one of the few
&ldquo;good&rdquo; uses of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29" class="RktValLink" data-pltdoc="x">eval</a></span> in Racket programming. Here&rsquo;s one way to do it:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Namespaces.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-namespace-anchor%29%29" class="RktStxLink" data-pltdoc="x">define-namespace-anchor</a></span><span class="hspace">&nbsp;</span><span class="RktSym">anchor</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-exn%29%29" class="RktValLink" data-pltdoc="x">check-exn</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._exn~3afail~3asyntax~3f%29%29" class="RktValLink" data-pltdoc="x">exn:fail:syntax?</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/parameters.html#%28form._%28%28lib._racket%2Fprivate%2Fmore-scheme..rkt%29._parameterize%29%29" class="RktStxLink" data-pltdoc="x">parameterize</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Namespaces.html#%28def._%28%28quote._~23~25kernel%29._current-namespace%29%29" class="RktValLink" data-pltdoc="x">current-namespace</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Namespaces.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._namespace-anchor-~3enamespace%29%29" class="RktValLink" data-pltdoc="x">namespace-anchor-&gt;namespace</a></span><span class="hspace">&nbsp;</span><span class="RktSym">anchor</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29" class="RktValLink" data-pltdoc="x">eval</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">assert</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">an-extra-argument</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Another solution is to catch the compile-time exception and &ldquo;save it&rdquo; until
run time. The <a href="https://docs.racket-lang.org/syntax/macro-testing.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">syntax/macro-testing</span></a> library has a form called
<span class="RktSym"><a href="https://docs.racket-lang.org/syntax/macro-testing.html#%28form._%28%28lib._syntax%2Fmacro-testing..rkt%29._convert-syntax-error%29%29" class="RktStxLink" data-pltdoc="x">convert-syntax-error</a></span> that does that:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="hspace">&nbsp;</span><span class="RktSym">syntax/macro-testing</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-exn%29%29" class="RktValLink" data-pltdoc="x">check-exn</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._exn~3afail~3asyntax~3f%29%29" class="RktValLink" data-pltdoc="x">exn:fail:syntax?</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/macro-testing.html#%28form._%28%28lib._syntax%2Fmacro-testing..rkt%29._convert-syntax-error%29%29" class="RktStxLink" data-pltdoc="x">convert-syntax-error</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assert</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">an-extra-argument</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote></div></p><p>That completes the design of the <span class="RktSym">assert</span> macro. We covered
specification, examples, implementation strategy, implementation, and testing.</p><h4>1.3<tt>&nbsp;</tt><a name="(part._intro-order)"></a>Expansion Contexts and Expansion Order</h4><p>Consider the shape of <span class="RktSym">assert</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(assert</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The first <span class="RktSym">Expr</span> is for the macro&rsquo;s argument. The second <span class="RktSym">Expr</span>,
though, says that <span class="RktSym">assert</span> forms a new kind of expression. But this also
points to a limitation of macros: <span class="RktSym">assert</span> is <span class="emph">only</span> a new kind of
expression.</p><p><div class="SIntrapara">Not every term in a program matching a macro&rsquo;s pattern is expanded (that is,
rewritten).  Macros are expanded only in certain positions, called
<span class="emph">expansion contexts</span>&#8212;<wbr></wbr>essentially, contexts where expressions or
definitions may appear. For example, if <span class="RktSym">assert</span> is the macro defined
above, then the following occurrences of <span class="RktSym">assert</span> do <span class="emph">not</span> count as
uses of the macro, and they don&rsquo;t get expanded: </div><div class="SIntrapara"><ul><li><p><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">assert</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3e%29%29" class="RktValLink" data-pltdoc="x">&gt;</a></span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">ok</span><span class="RktPn">)</span> &#8212;<wbr></wbr> This occurrence of
<span class="RktSym">assert</span> is in a <span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span>-binding; <span class="RktSym">assert</span> is interpreted as
a variable name to bind to the value of <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3e%29%29" class="RktValLink" data-pltdoc="x">&gt;</a></span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span>. In Racket, names like
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span>, <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span>, and <span class="RktSym">assert</span> can be shadowed just like
variables can!</p></li><li><p><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">assert</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">nope</span><span class="RktPn">]</span><span class="RktPn">)</span> &#8212;<wbr></wbr> This is a syntax
error. The <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span> form treats <span class="RktSym">assert</span> and <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">)</span> as
separate expressions, and the use of <span class="RktSym">assert</span> as an expression by itself
is a syntax error (the use does not match <span class="RktSym">assert</span>&rsquo;s pattern).</p></li><li><p><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">assert</span><span class="stt"> </span><span class="RktVal">#f</span><span class="RktVal">)</span> &#8212;<wbr></wbr> This <span class="RktSym">assert</span> occurs as part of a
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span>d constant.</p></li></ul></div></p><p>Note that <span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span> and <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span> are also macros. So we cannot even tell
whether a term involving <span class="RktSym">assert</span> is used as an expression until we
understand the shapes of the surrounding macros. In particular, the Racket macro
expander expands macros in &ldquo;outermost-first&rdquo; order, in contrast to nested
function calls, which are evaluated &ldquo;innermost-first.&rdquo; The outermost-first
expansion order is necessary because the macro expander only knows the shapes
(and thus the expansion contexts) of primitive syntactic forms; it must expand
away the outer macros so that it knows what inner terms need to be expanded.</p><h4>1.4<tt>&nbsp;</tt><a name="(part._intro-lexical)"></a>Proper Lexical Scoping</h4><p>Given that <span class="RktSym">assert</span> just expands into uses of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span>,
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span>, and so on, perhaps we could interfere with its intended behavior
by locally shadowing names it depends on &#8212;<wbr></wbr> <span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span>, for example. But if
we try it, we can see it has no effect:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assert</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktErr">assert: assertion failed: '(even? (length ls))</span></p></td></tr></table></blockquote><p>The <span class="RktSym">assert</span> macro is <span class="emph">properly lexically scoped</span>, or
<span class="emph">hygienic</span>. Roughly, that means that references in <span class="RktSym">assert</span>&rsquo;s syntax
template are resolved in the environment where the macro was defined, not the
environment where it is used. This is analogous to the behavior you would get if
<span class="RktSym">assert</span> were a function: functions automatically close over their free
variables. In the case of macros, it is syntax objects that contain information
about the syntax&rsquo;s <span class="emph">lexical context</span>.</p><p><div class="SIntrapara">In other words, the following &ldquo;naive&rdquo; code is the wrong explanation for the
expansion of this <span class="RktSym">assert</span> example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">WRONG</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: ~s"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Instead, each term introduced by <span class="RktSym">assert</span> carries some lexical context
information with it. Here&rsquo;s a better way to think of the expansion:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span style="vertical-align: super; font-size: 80%">m</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span style="vertical-align: super; font-size: 80%">m</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: ~s"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span style="vertical-align: super; font-size: 80%">m</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">The lexical contexts of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span> and <span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span style="vertical-align: super; font-size: 80%">m</span>
prevents the use-site local binding of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span> from capturing the
reference <span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span style="vertical-align: super; font-size: 80%">m</span>.</div></p><p>This example illustrates one half of <span class="emph">hygienic macro expansion</span>. We&rsquo;ll talk
about the other half in <a href="#%28part._basic-hygiene2%29" data-pltdoc="x">Proper Lexical Scoping, Part 2</a>.</p><h4>1.5<tt>&nbsp;</tt><a name="(part._intro-impl)"></a>More Implementations of <span class="RktSym">assert</span></h4><p>Given that we have all of &ldquo;ordinary&rdquo; Racket plus several different
macro-defining DSLs available for the implementation of <span class="RktSym">assert</span>&rsquo;s
transformer function, there are many other ways we could implement it. This
section introduces a few of them.</p><p><div class="SIntrapara">A <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax%29%29" class="RktStxLink" data-pltdoc="x">syntax</a></span><span class="stt"> </span><span class="RktVar">template</span><span class="RktPn">)</span> expression can be written as <span class="RktRdr">#'</span><span class="RktVar">template</span>
instead. That is, <span class="RktInBG"><span class="hspace"></span><span class="RktIn">#'</span><span class="hspace"></span></span> is a reader macro for <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax%29%29" class="RktStxLink" data-pltdoc="x">syntax</a></span>. So the
<span class="RktSym">assert</span> macro can be defined as follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(assert Expr) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">assert</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: ~e"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">The <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span> form is basically a combination of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span>
and <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parse%29%29" class="RktStxLink" data-pltdoc="x">syntax-parse</a></span>. So the following definition is equivalent:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(assert Expr) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">assert</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">stx</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parse%29%29" class="RktStxLink" data-pltdoc="x">syntax-parse</a></span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: ~e"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">The <span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span> form supports &ldquo;function definition&rdquo; syntax like
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span> does, so the following is also allowed:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(assert Expr) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assert</span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parse%29%29" class="RktStxLink" data-pltdoc="x">syntax-parse</a></span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: ~e"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">A macro&rsquo;s transformer function is, in a sense just an ordinary Racket function,
except that it exists at compile time. When we imported <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._for-syntax%29%29" class="RktStxLink" data-pltdoc="x">for-syntax</a></span><span class="stt"> </span><span class="RktSym">racket/base</span><span class="RktPn">)</span> earlier, we made the Racket language available at compile time. We
can define the transformer as a separate compile-time function using
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span>; the definitions it contains are added to the
compile-time environment. Then we can simply use a reference to the function as
the implementation of <span class="RktSym">assert</span>.
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">assert-transformer : Syntax[(_ Expr)] -&gt; Syntax[Expr]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assert-transformer</span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parse%29%29" class="RktStxLink" data-pltdoc="x">syntax-parse</a></span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: ~e"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(assert Expr) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">assert</span><span class="hspace">&nbsp;</span><span class="RktSym">assert-transformer</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Note: There are two differences between <span class="RktSym">assert</span> and
<span class="RktSym">assert-transformer</span>. The name <span class="RktSym">assert</span> is bound as a <span class="emph">macro</span>
in the <span class="emph">normal environment</span> (also called the <span class="emph">run-time environment</span> or
the <span class="emph">phase-0 environment</span>), whereas the name <span class="RktSym">assert-transformer</span> is
bound as a <span class="emph">variable</span> in the <span class="emph">compile-time environment</span> (also called
the <span class="emph">transformer environment</span> or the <span class="emph">phase-1 environment</span>). Both of
them are associated with a compile-time value, but <span class="RktSym">assert-transformer</span>
is not a macro; if you replace <span class="RktSym">assert</span> with <span class="RktSym">assert-transformer</span>
in the tests above, they will not even compile. Likewise, you cannot use
<span class="RktSym">assert</span> in a compile-time expression, either as a macro or as a
variable. The separation of run-time and compile-time environments is part of
Racket&rsquo;s <span class="emph">phase separation</span>.</p><p>In addition to <a href="https://docs.racket-lang.org/syntax/stxparse.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">syntax/parse</span></a>, Racket also inherits Scheme&rsquo;s older
macro-definition DSLs: <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax-rules%29%29" class="RktStxLink" data-pltdoc="x">syntax-rules</a></span> and <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax-case%29%29" class="RktStxLink" data-pltdoc="x">syntax-case</a></span>, and they
are used in much existing Racket code. Here are versions of <span class="RktSym">assert</span>
written using those systems:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fmisc..rkt%29._define-syntax-rule%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-rule</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assert</span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: ~s"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">assert</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax-rules%29%29" class="RktStxLink" data-pltdoc="x">syntax-rules</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: ~s"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assert</span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax-case%29%29" class="RktStxLink" data-pltdoc="x">syntax-case</a></span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: ~s"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>For a macro as simple as <span class="RktSym">assert</span>, there isn&rsquo;t much difference. All of
the systems share broadly similar concepts such as syntax patterns and
templates. The <a href="https://docs.racket-lang.org/syntax/stxparse.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">syntax/parse</span></a> system evolved out of
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax-case%29%29" class="RktStxLink" data-pltdoc="x">syntax-case</a></span>; <a href="https://docs.racket-lang.org/syntax/stxparse.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">syntax/parse</span></a> adds a more sophisticated
pattern language and a more expressive way of organizing compile-time syntax
validation and computation.</p><p>All of these pattern-matching DSLs are simply aids to writing macros; they
aren&rsquo;t necessary. It&rsquo;s possible to write the macro by directly using the syntax
object API. Here&rsquo;s one version:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">assert</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">stx</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">parts</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._syntax-~3elist%29%29" class="RktValLink" data-pltdoc="x">syntax-&gt;list</a></span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">parts : (U (Listof Syntax) #f)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._and%29%29" class="RktStxLink" data-pltdoc="x">and</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list~3f%29%29" class="RktValLink" data-pltdoc="x">list?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">parts</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">parts</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._raise-syntax-error%29%29" class="RktValLink" data-pltdoc="x">raise-syntax-error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="hspace">&nbsp;</span><span class="RktVal">"bad syntax"</span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition-stx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">parts</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">condition-stx : Syntax[Expr]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">code</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Syntax_Quoting__quote-syntax.html#%28form._%28%28quote._~23~25kernel%29._quote-syntax%29%29" class="RktStxLink" data-pltdoc="x">quote-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">condition-stx</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Syntax_Quoting__quote-syntax.html#%28form._%28%28quote._~23~25kernel%29._quote-syntax%29%29" class="RktStxLink" data-pltdoc="x">quote-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Syntax_Quoting__quote-syntax.html#%28form._%28%28quote._~23~25kernel%29._quote-syntax%29%29" class="RktStxLink" data-pltdoc="x">quote-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Syntax_Quoting__quote-syntax.html#%28form._%28%28quote._~23~25kernel%29._quote-syntax%29%29" class="RktStxLink" data-pltdoc="x">quote-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: ~s"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Syntax_Quoting__quote-syntax.html#%28form._%28%28quote._~23~25kernel%29._quote-syntax%29%29" class="RktStxLink" data-pltdoc="x">quote-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">condition-stx</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._datum-~3esyntax%29%29" class="RktValLink" data-pltdoc="x">datum-&gt;syntax</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Syntax_Quoting__quote-syntax.html#%28form._%28%28quote._~23~25kernel%29._quote-syntax%29%29" class="RktStxLink" data-pltdoc="x">quote-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">here</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">code</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Briefly, <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._syntax-~3elist%29%29" class="RktValLink" data-pltdoc="x">syntax-&gt;list</a></span> unwraps a syntax object one level and normalizes
it to a list, if possible (the terms <span class="RktPn">(</span><span class="RktSym">a</span><span class="stt"> </span><span class="RktSym">b</span><span class="stt"> </span><span class="RktSym">c</span><span class="RktPn">)</span> and <span class="RktPn">(</span><span class="RktSym">a</span><span class="stt"> </span><span class="RktPn">.</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">b</span><span class="stt"> </span><span class="RktSym">c</span><span class="RktPn">)</span><span class="RktPn">)</span>,
while both &ldquo;syntax lists&rdquo;, have different syntax object representations). It
is built on top of the primitive operation <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._syntax-e%29%29" class="RktValLink" data-pltdoc="x">syntax-e</a></span>. The
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/Syntax_Quoting__quote-syntax.html#%28form._%28%28quote._~23~25kernel%29._quote-syntax%29%29" class="RktStxLink" data-pltdoc="x">quote-syntax</a></span> form is the primitive that creates a syntax object
constant for a term that captures the lexical context of the term itself. The
lexical context can be transferred to a tree using <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._datum-~3esyntax%29%29" class="RktValLink" data-pltdoc="x">datum-&gt;syntax</a></span>; it
wraps pairs, atoms, etc, but it leaves existing syntax objects unchanged.</p><p>Here is a variant of the previous definition that uses <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fqqstx..rkt%29._quasisyntax%29%29" class="RktStxLink" data-pltdoc="x">quasisyntax</a></span>
(reader abbreviation <span class="RktInBG"><span class="hspace"></span><span class="RktIn">#`</span><span class="hspace"></span></span>) and <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fqqstx..rkt%29._unsyntax%29%29" class="RktStxLink" data-pltdoc="x">unsyntax</a></span> (reader abbreviation
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">#,</span><span class="hspace"></span></span>) to construct the macro&rsquo;s result:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">assert</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">stx</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">parts</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._syntax-~3elist%29%29" class="RktValLink" data-pltdoc="x">syntax-&gt;list</a></span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">parts : (U (Listof Syntax) #f)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._and%29%29" class="RktStxLink" data-pltdoc="x">and</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list~3f%29%29" class="RktValLink" data-pltdoc="x">list?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">parts</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">parts</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._raise-syntax-error%29%29" class="RktValLink" data-pltdoc="x">raise-syntax-error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="hspace">&nbsp;</span><span class="RktVal">"bad syntax"</span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition-stx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">parts</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">condition-stx : Syntax[Expr]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#`</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._unless%29%29" class="RktStxLink" data-pltdoc="x">unless</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#,</span><span class="RktSym">condition-stx</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assert</span><span class="hspace">&nbsp;</span><span class="RktVal">"assertion failed: ~s"</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">#,</span><span class="RktVal">condition-stx</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>It is not a goal of this guide to introduce you to every bit of machinery that
can be used to implement macros. In general, this guide will stick to the
<a href="https://docs.racket-lang.org/syntax/stxparse.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">syntax/parse</span></a> system for macro definitions, and it uses the
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">#'</span><span class="hspace"></span></span> abbreviation for <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax%29%29" class="RktStxLink" data-pltdoc="x">syntax</a></span> expressions. It will sometimes be
necessary to use the lower-level APIs (such as <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._syntax-~3elist%29%29" class="RktValLink" data-pltdoc="x">syntax-&gt;list</a></span>,
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">#`</span><span class="hspace"></span></span> and <span class="RktInBG"><span class="hspace"></span><span class="RktIn">#,</span><span class="hspace"></span></span>) to perform auxiliary computations.</p><p>On the other hand, it is a goal of this guide to discuss and compare different
implementation strategies. So the following sections do often present multiple
implementations of the same macro according to different strategies.</p><h3>2<tt>&nbsp;</tt><a name="(part._shapes)"></a>Terms and Shapes</h3><p>This section introduces terminology for talking about the pieces of Racket
programs and their interpretation. In particular, it introduces the idea of
<span class="emph">shapes</span>, which we will use as the specification language that drives macro
design and organizes implementation strategies.</p><h4>2.1<tt>&nbsp;</tt><a name="(part._shapes-terms)"></a>Terms</h4><p>Consider the following Racket code:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._map%29%29" class="RktValLink" data-pltdoc="x">map</a></span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._map%29%29" class="RktValLink" data-pltdoc="x">map</a></span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._null~3f%29%29" class="RktValLink" data-pltdoc="x">null?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p><div class="SIntrapara">The code is a tree of terms. A <a name="(tech._term)"></a><span style="font-style: italic">term</span> is, roughly, an atom or a
parenthesized group of terms. So all of the following are terms:
</div><div class="SIntrapara"><ul><li><p><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span>, <span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._map%29%29" class="RktValLink" data-pltdoc="x">map</a></span>, <span class="RktSym">xs</span>, <span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span> &#8212;<wbr></wbr> More
specifically, these are <span class="emph">identifier terms</span>.</p></li><li><p><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span><span class="stt"> </span><span class="RktSym">xs</span><span class="RktPn">)</span>, <span class="RktPn">(</span><span class="RktSym">f</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="stt"> </span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span>, <span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._null~3f%29%29" class="RktValLink" data-pltdoc="x">null?</a></span><span class="stt"> </span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">]</span> &#8212;<wbr></wbr>
More specifically, these are <span class="emph">list terms</span>.</p></li><li><p><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span> &#8212;<wbr></wbr> This is also a list term, because it is read as
<span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">)</span>.</p></li></ul></div></p><p><div class="SIntrapara">The following is not a term:
</div><div class="SIntrapara"><ul><li><p><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._map%29%29" class="RktValLink" data-pltdoc="x">map</a></span><span class="stt"> </span><span class="RktSym">f</span> &#8212;<wbr></wbr> That&rsquo;s two terms.</p></li></ul></div></p><p><div class="SIntrapara">The following are also terms that occur in the program above, even though it
might not be immediately apparent:
</div><div class="SIntrapara"><ul><li><p><span class="RktPn">(</span><span class="RktSym">f</span><span class="stt"> </span><span class="RktSym">xs</span><span class="RktPn">)</span> &#8212;<wbr></wbr> Because <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._map%29%29" class="RktValLink" data-pltdoc="x">map</a></span><span class="stt"> </span><span class="RktSym">f</span><span class="stt"> </span><span class="RktSym">xs</span><span class="RktPn">)</span> is the same as
<span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._map%29%29" class="RktValLink" data-pltdoc="x">map</a></span><span class="stt"> </span><span class="RktPn">.</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">f</span><span class="stt"> </span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span>, which is also the same as <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._map%29%29" class="RktValLink" data-pltdoc="x">map</a></span><span class="stt"> </span><span class="RktPn">.</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">f</span><span class="stt"> </span><span class="RktPn">.</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">xs</span><span class="stt"> </span><span class="RktPn">.</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span>.</p></li><li><p><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> &#8212;<wbr></wbr> Because it&rsquo;s a subterm of <span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span>, which is the
same as <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">)</span>.</p></li></ul></div></p><p><div class="SIntrapara">Here are some other terms that don&rsquo;t appear in the program above:
</div><div class="SIntrapara"><ul><li><p><span class="RktVal">#t</span>, <span class="RktVal">5</span>, <span class="RktVal">#e1e3</span>,
<span class="RktVal">"racket-lang.org"</span>, <span class="RktVal">#</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktVal">3</span><span class="RktVal">)</span>, <span class="RktVal">#s</span><span class="RktVal">(</span><span class="RktVal">point</span><span class="stt"> </span><span class="RktVal">3</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktVal">)</span>,
<span class="RktPn">#:unless</span>, <span class="RktVal">#rx"[01]+"</span> &#8212;<wbr></wbr> A <span class="emph">boolean term</span>, two
<span class="emph">number terms</span>, a <span class="emph">string term</span>, and so on.</p></li></ul></div></p><p>Racket represents terms using <span class="emph">syntax objects</span>, a kind of value.</p><p>It will be helpful to keep the two levels separate (term vs value
representation), but that&rsquo;s hard, because we don&rsquo;t have enough distinct terms
(err, I mean words) to name everything. In some cases, the context should either
make the usage clear or make the distinction moot. In some cases, I&rsquo;ll
disambiguate by saying, for example, <span class="emph">identifier term</span> vs <span class="emph">identifier
value</span>.</p><h4>2.2<tt>&nbsp;</tt><a name="(part._shapes-interps)"></a>Interpretations of Terms</h4><p>What is an expression?</p><p>The concept of &ldquo;expression&rdquo; doesn&rsquo;t simply refer to some subset of
terms. <span class="emph">Any</span> term can be an expression, given the right context. And a term
might be an expression when used in one place but not when used in another. Is
the identifier <span class="RktSym">f</span> an expression? In the example code above, the first
occurrence of <span class="RktSym">f</span> is not an expression, but the second and third
occurrences are expressions. It depends on context &#8212;<wbr></wbr> that is, where the term
appears in the code. The term <span class="RktSym">f</span> isn&rsquo;t an expression when it occurs in
the function definition&rsquo;s formal parameter list, but it is an expression when it
occurs in operator position of an application. What is an &ldquo;application&rdquo;? Well,
it&rsquo;s a kind of expression &#8212;<wbr></wbr> and so we have to keep looking outward to figure
out what&rsquo;s going on.</p><p>Here&rsquo;s the reasoning for the second and third occurrences of <span class="RktSym">f</span> being
expressions: The example is a use of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span>, and the rule for
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span> is that the body is an expression (that&rsquo;s an oversimplification,
actually). The body is a <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span> expression, and a <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span>
expression&rsquo;s arguments are &ldquo;clauses&rdquo;, which are not expressions themselves,
but consist of two expressions grouped together (again, oversimplified). The
second expression of the first <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span> clause is a function call to
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span>, so its first argument is an expression. And that expression is a
function call (because <span class="RktSym">f</span> is bound as a variable), so that <span class="RktSym">f</span> is
an expression. And that&rsquo;s how we know, starting from the top.</p><p>Of course, if we wrap <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> around the whole thing, then all of that
reasoning is invalidated, because the argument of a <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> expression is
not interpreted as a definition or expression.</p><p><div class="SIntrapara">So &ldquo;expression&rdquo; doesn&rsquo;t refer to a subset of terms (decidable or not). But
that doesn&rsquo;t mean that it isn&rsquo;t an important concept. Rather, &ldquo;expression&rdquo;
describes an <span class="emph">interpretation</span> or <span class="emph">intended usage</span> of a term. Here are
names for the main interpretations that are handled by Racket&rsquo;s macro expander:
</div><div class="SIntrapara"><ul><li><p><span class="emph">expression</span> or <span class="emph">expression term</span> &#8212;<wbr></wbr> Used in an expression
position, like the test of an <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span> or an argument to a function.</p></li><li><p><span class="emph">body term</span> &#8212;<wbr></wbr> Used as one element of a <span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span> body,
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span> body, etc. A &ldquo;body&rdquo; is also called an &ldquo;internal definition
context&rdquo;.</p></li><li><p><span class="emph">module-level term</span> &#8212;<wbr></wbr> Used as one element of a <span class="RktSym"><a href="https://docs.racket-lang.org/reference/module.html#%28form._%28%28quote._~23~25kernel%29._module%29%29" class="RktStxLink" data-pltdoc="x">module</a></span> body
or submodule body.</p></li><li><p><span class="emph">top-level term</span> &#8212;<wbr></wbr> Used at the top level, for example at the REPL
or in a call to <span class="RktSym"><a href="https://docs.racket-lang.org/reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29" class="RktValLink" data-pltdoc="x">eval</a></span>.</p></li></ul></div></p><p>The word <a name="(tech._form)"></a><span style="font-style: italic">form</span> is used to identify a variant of expression,
module-level term, etc. The concept of &ldquo;variant&rdquo; usually coincides with the
leading identifier of the term. For example: <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span> is an expression form;
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._provide%29%29" class="RktStxLink" data-pltdoc="x">provide</a></span> is a module-level form but not a top-level form, but
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span> is allowed both as a module-level form and as a top-level form.</p><p>The word <span class="emph">form</span> can also refer to the entire term, as in &ldquo;<span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="stt"> </span><span class="RktSym">racket/list</span><span class="RktPn">)</span> is a module-level form&rdquo;.</p><p>The word <span class="emph">definition</span> refers to a subset of the body forms, roughly. In
fact, we could say that a body term is either an expression or a definition.</p><h4>2.3<tt>&nbsp;</tt><a name="(part._shapes-shapes)"></a>Shapes</h4><p>When we design a macro, the intended interpretation of an argument can be as
important or more important than the set of terms allowed for that argument. To
usefully describe macros and the ways they treat their arguments, we need to
talk about both of these aspects. We&rsquo;ll do that with a semi-formal description
language of <span class="emph">shapes</span>.</p><p><div class="SIntrapara">A shape has two aspects:
</div><div class="SIntrapara"><ul><li><p>the <span class="emph">set of terms</span> belonging to the shape, and</p></li><li><p>the <span class="emph">interpretation</span> or intended usage of the terms of that shape</p></li></ul></div><div class="SIntrapara">Different basic shapes place different degrees of emphasis on these two aspects.</div></p><p>A shape is not the same thing as a syntax pattern, although there is generally a
correspondence between shapes and patterns. In particular, we&rsquo;ll use implement
basic shapes using <span class="emph">syntax classes</span>. A syntax class check terms for
membership in the shape&rsquo;s set of terms and it can compute attributes related to
the interpretation of the shape. But a syntax class cannot always check every
aspect of a shape&rsquo;s interpretation; for example, a syntax class cannot verify
that we use a term in an expression position in the code that we generate. That
obligation stays with the macro writer.</p><p>The following sections introduce different shapes and show how they affect the
design and implementation of macros that use them.</p><h3>3<tt>&nbsp;</tt><a name="(part._basic-shapes)"></a>Basic Shapes</h3><p>This section introduces the most important basic shapes for macro design.</p><h4>3.1<tt>&nbsp;</tt><a name="(part._basic-expr)"></a>The Expr (Expression) Shape</h4><p>The <span class="RktCmt">Expr</span> shape represents the intention to interpret the term as a
Racket expression by putting it in an expression context. In general, a macro
cannot check a term and decide whether it is a valid expression; only the Racket
macro expander can do that. As a pragmatic approximation, the <span class="RktCmt">Expr</span> shape
and its associated <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span> syntax class exclude only keyword terms, like
<span class="RktPn">#:when</span>, so that macros can detect and report misuses of keyword
arguments.</p><p><div class="SIntrapara">As an example, let&rsquo;s implement <span class="RktSym">my-when</span>, a simple version of Racket&rsquo;s
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/when_unless.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._when%29%29" class="RktStxLink" data-pltdoc="x">when</a></span> form. It takes two expressions; the first is the condition, and
the second is the result to be evaluated only if the condition is true. Here is
the shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-when</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Here are some examples:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"odd!\n"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect print</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"even!\n"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect no print</span></td></tr></table></blockquote></div><div class="SIntrapara">Here&rsquo;s the implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-when</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="hspace">&nbsp;</span><span class="RktSym">result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">We use the <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span> syntax class to annotate pattern variables that have
the <span class="RktCmt">Expr</span> shape. Note that the names of the pattern variables do not
include the <span class="RktSym">:expr</span> annotation, so in the syntax template we simply
write <span class="RktSym">condition</span> and <span class="RktSym">result</span>.</div></p><p><div class="SIntrapara">To test the macro, we rephrase the previous examples as tests:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"odd!\n"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">"odd!\n"</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"even!\n"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">""</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-exn%29%29" class="RktValLink" data-pltdoc="x">check-exn</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._exn~3afail~3asyntax~3f%29%29" class="RktValLink" data-pltdoc="x">exn:fail:syntax?</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/macro-testing.html#%28form._%28%28lib._syntax%2Fmacro-testing..rkt%29._convert-syntax-error%29%29" class="RktStxLink" data-pltdoc="x">convert-syntax-error</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">#:truth</span><span class="hspace">&nbsp;</span><span class="RktVal">"verity"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote></div></p><blockquote class="SubFlow"><p><div class="SIntrapara"><a name="(exercise._basic~3ashape-violation)"></a><span style="font-weight: bold">Exercise&#160;1: </span>Each of the following uses of
<span class="RktSym">my-when</span> violates its declared shape:
</div><div class="SIntrapara"><ul><li><p><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="stt"> </span><span class="RktPn">#:true</span><span class="stt"> </span><span class="RktVal">"verity"</span><span class="RktPn">)</span></p></li><li><p><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">ok</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="stt"> </span><span class="RktSym">ns</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktVal">3</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="stt"> </span><span class="RktSym">ns</span><span class="RktPn">)</span><span class="RktPn">)</span></p></li><li><p><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin%29%29" class="RktStxLink" data-pltdoc="x">begin</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="stt"> </span><span class="RktSym">one</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktSym">one</span><span class="stt"> </span><span class="RktSym">one</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></li><li><p><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="stt"> </span><span class="RktVal">#f</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktPn">#:one</span><span class="stt"> </span><span class="RktPn">#:two</span><span class="RktPn">)</span><span class="RktPn">)</span></p></li></ul></div><div class="SIntrapara">Why? Which examples are rejected by the <span class="RktSym">my-when</span> macro itself, and
what happens to the other examples? What difference does it make if you remove
the <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span> syntax class annotations from the macro definition?</div></p></blockquote><blockquote class="SubFlow"><p><a name="(exercise._basic~3amy-unless)"></a><span style="font-weight: bold">Exercise&#160;2: </span>Design a macro <span class="RktSym">my-unless</span> like
<span class="RktSym">my-when</span>, except that it negates the condition.</p></blockquote><blockquote class="SubFlow"><p><a name="(exercise._basic~3acatch-output)"></a><span style="font-weight: bold">Exercise&#160;3: </span>Design a macro <span class="RktSym">catch-output</span> that
takes a single expression argument. The expression is evaluated, but its result
is ignored; instead, the result of the macro is a string containing all of the
output written by the expression. For example:</p><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">catch-output</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/for.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._for%29%29" class="RktStxLink" data-pltdoc="x">for</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">i</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"~s"</span><span class="hspace">&nbsp;</span><span class="RktSym">i</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect "0123456789"</span></p></blockquote></blockquote><h4>3.2<tt>&nbsp;</tt><a name="(part._basic-body)"></a>The Body Shape</h4><p>The <span class="RktCmt">Body</span> shape is like <span class="RktCmt">Expr</span> except that it indicates that the
term will be used in a body context, so definitions are allowed in addition to
expressions.</p><p>There is no distinct syntax class for <span class="RktCmt">Body</span>; just use <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span>.</p><p>In practice, the <span class="RktCmt">Body</span> shape is usually used with ellipses; see
<a href="#%28part._compound-shapes%29" data-pltdoc="x">Compound Shapes</a>. But we can make a version of <span class="RktSym">my-when</span> that
takes a single <span class="RktCmt">Body</span> term, even though it isn&rsquo;t idiomatic Racket
syntax. Here is the shape:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-when</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Body)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote><p><div class="SIntrapara">Here is an example allowed by the new shape but not by the previous shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">37</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin%29%29" class="RktStxLink" data-pltdoc="x">begin</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">q</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._quotient%29%29" class="RktValLink" data-pltdoc="x">quotient</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"q = ~s\n"</span><span class="hspace">&nbsp;</span><span class="RktSym">q</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Given the new shape, the previous implementation would be wrong, since it
does not place its second argument in a body context. Here is an updated
implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-when</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result-body:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/block.html#%28form._%28%28lib._racket%2Fblock..rkt%29._block%29%29" class="RktStxLink" data-pltdoc="x">block</a></span><span class="hspace">&nbsp;</span><span class="RktSym">result-body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>That is, use <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/block.html#%28form._%28%28lib._racket%2Fblock..rkt%29._block%29%29" class="RktStxLink" data-pltdoc="x">block</a></span><span class="stt"> </span><span style="color: lightgray">&#9251;</span><span class="RktPn">)</span> to wrap a <span class="RktCmt">Body</span> so it can be used in a
strict <span class="RktCmt">Expr</span> position. It is also common to use a <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">)</span><span class="stt"> </span><span style="color: lightgray">&#9251;</span><span class="RktPn">)</span>
wrapper, but that does not work for all <span class="RktCmt">Body</span> terms; it requires that the
<span class="RktCmt">Body</span> term ends with an expression. The <span class="RktSym"><a href="https://docs.racket-lang.org/reference/block.html#%28form._%28%28lib._racket%2Fblock..rkt%29._block%29%29" class="RktStxLink" data-pltdoc="x">block</a></span> form is more
flexible.</p><p><div class="SIntrapara">Racket&rsquo;s <span class="RktSym"><a href="https://docs.racket-lang.org/reference/__expression.html#%28form._%28%28quote._~23~25kernel%29._~23~25expression%29%29" class="RktStxLink" data-pltdoc="x">#%expression</a></span> form is useful in the opposite situation. It has
the following shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(#%expression</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Body</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">That is, use <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/__expression.html#%28form._%28%28quote._~23~25kernel%29._~23~25expression%29%29" class="RktStxLink" data-pltdoc="x">#%expression</a></span><span class="stt"> </span><span style="color: lightgray">&#9251;</span><span class="RktPn">)</span> to turn a <span class="RktCmt">Body</span> position into a
strict <span class="RktCmt">Expr</span> position.</div></p><blockquote class="SubFlow"><p><div class="SIntrapara"><a name="(exercise._basic~3acatch-output-expr)"></a><span style="font-weight: bold">Exercise&#160;4: </span>Check your solution to
<a href="#%28exercise._basic~3acatch-output%29" data-pltdoc="x">Exercise&#160;3</a>; does the macro also accept <span class="RktCmt">Body</span>
terms like the one above? That is, does the following work?
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">catch-output</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin%29%29" class="RktStxLink" data-pltdoc="x">begin</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">q</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._quotient%29%29" class="RktValLink" data-pltdoc="x">quotient</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"q = ~s\n"</span><span class="hspace">&nbsp;</span><span class="RktSym">q</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></div><div class="SIntrapara">If so, &ldquo;fix it&rdquo; (that is, make it more restrictive) using
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/__expression.html#%28form._%28%28quote._~23~25kernel%29._~23~25expression%29%29" class="RktStxLink" data-pltdoc="x">#%expression</a></span>.</div></p></blockquote><h4>3.3<tt>&nbsp;</tt><a name="(part._basic-hygiene2)"></a>Proper Lexical Scoping, Part 2</h4><p><div class="SIntrapara">Here is one solution to <a href="#%28exercise._basic~3acatch-output%29" data-pltdoc="x">Exercise&#160;3</a> using
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(catch-output Expr) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">catch-output</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">e:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/__expression.html#%28form._%28%28quote._~23~25kernel%29._~23~25expression%29%29" class="RktStxLink" data-pltdoc="x">#%expression</a></span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Racket already provides <span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span> from the
<a href="https://docs.racket-lang.org/reference/port-lib.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">racket/port</span></a> library, but if it did not, we could define it as
follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">with-output-to-string : (-&gt; Any) -&gt; String</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">proc</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">out</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stringport.html#%28def._%28%28quote._~23~25kernel%29._open-output-string%29%29" class="RktValLink" data-pltdoc="x">open-output-string</a></span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/parameters.html#%28form._%28%28lib._racket%2Fprivate%2Fmore-scheme..rkt%29._parameterize%29%29" class="RktStxLink" data-pltdoc="x">parameterize</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-ops.html#%28def._%28%28quote._~23~25kernel%29._current-output-port%29%29" class="RktValLink" data-pltdoc="x">current-output-port</a></span><span class="hspace">&nbsp;</span><span class="RktSym">out</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">proc</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stringport.html#%28def._%28%28quote._~23~25kernel%29._get-output-string%29%29" class="RktValLink" data-pltdoc="x">get-output-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">out</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here is another implementation of <span class="RktSym">catch-output</span>, which essentially
inlines the definition of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-lib.html#%28def._%28%28lib._racket%2Fport..rkt%29._with-output-to-string%29%29" class="RktValLink" data-pltdoc="x">with-output-to-string</a></span> into the macro
template:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(catch-output Expr) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">catch-output</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">e:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">out</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stringport.html#%28def._%28%28quote._~23~25kernel%29._open-output-string%29%29" class="RktValLink" data-pltdoc="x">open-output-string</a></span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/parameters.html#%28form._%28%28lib._racket%2Fprivate%2Fmore-scheme..rkt%29._parameterize%29%29" class="RktStxLink" data-pltdoc="x">parameterize</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/port-ops.html#%28def._%28%28quote._~23~25kernel%29._current-output-port%29%29" class="RktValLink" data-pltdoc="x">current-output-port</a></span><span class="hspace">&nbsp;</span><span class="RktSym">out</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/__expression.html#%28form._%28%28quote._~23~25kernel%29._~23~25expression%29%29" class="RktStxLink" data-pltdoc="x">#%expression</a></span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stringport.html#%28def._%28%28quote._~23~25kernel%29._get-output-string%29%29" class="RktValLink" data-pltdoc="x">get-output-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">out</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">In <a href="#%28part._intro-lexical%29" data-pltdoc="x">Proper Lexical Scoping</a> we saw that we cannot interfere with a macro&rsquo;s
&ldquo;free variables&rdquo; by shadowing them at the macro use site. For example, the
following attempt to capture the macro&rsquo;s reference to <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stringport.html#%28def._%28%28quote._~23~25kernel%29._get-output-string%29%29" class="RktValLink" data-pltdoc="x">get-output-string</a></span>
fails:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stringport.html#%28def._%28%28quote._~23~25kernel%29._get-output-string%29%29" class="RktValLink" data-pltdoc="x">get-output-string</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"pwned!"</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">catch-output</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"doing just fine, actually"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">"doing just fine, actually"</span></p></td></tr></table></blockquote></div></p><p>But what about the other direction? The macro introduces a binding of a variable
named <span class="RktSym">out</span>; could this binding capture references to <span class="RktSym">out</span> in the
expression given to the macro? Here is an example:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">out</span><span class="hspace">&nbsp;</span><span class="RktVal">"Aisle 24"</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">catch-output</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"The exit is located at ~a."</span><span class="hspace">&nbsp;</span><span class="RktSym">out</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">"The exit is located at Aisle 24."</span></p></td></tr></table></blockquote><p>The result shows that the macro&rsquo;s <span class="RktSym">out</span> binding does not interfere with
the use-site&rsquo;s <span class="RktSym">out</span> variable. We say that the <span class="RktSym">catch-output</span>
macro is &ldquo;hygienic&rdquo;.</p><p><div class="SIntrapara">A macro is <span class="emph">hygienic</span> if it follows these two lexical scoping principles:
</div><div class="SIntrapara"><ol><li><p>A <span class="emph">use-site binding</span> does not capture a <span class="emph">definition-site
reference</span>.</p></li><li><p>A <span class="emph">definition-site binding</span> does not capture a <span class="emph">use-site
reference</span>.</p></li></ol></div><div class="SIntrapara">Racket macros are hygienic by default. In FIXME-REF we will discuss a few
situations when it is useful to break hygiene.</div></p><h4>3.4<tt>&nbsp;</tt><a name="(part._basic-id)"></a>The Id (Identifier) Shape</h4><p>The <span class="RktCmt">Id</span> shape contains all identifier terms.</p><p>The <span class="RktCmt">Id</span> shape usually implies that the identifier will be used as the
name for a variable, macro, or other sort of binding. In that case, we say the
identifer is used as a <span class="emph">binder</span>.</p><p>Use the <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._id%29%29" class="RktStxLink" data-pltdoc="x">id</a></span> syntax class for pattern variables whose shape is <span class="RktCmt">Id</span>.</p><p><div class="SIntrapara">Let&rsquo;s write a macro <span class="RktSym">my-and-let</span> that acts like <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._and%29%29" class="RktStxLink" data-pltdoc="x">and</a></span> with two
expressions but binds the result of the first expression to the given identifier
before evaluating the second expression. Here is the shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-and-let</span><span class="hspace">&nbsp;</span><span class="RktCmt">Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Here are some examples:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">a</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">c</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-and-let</span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._assoc%29%29" class="RktValLink" data-pltdoc="x">assoc</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect 2</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-and-let</span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._assoc%29%29" class="RktValLink" data-pltdoc="x">assoc</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">z</span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect #f</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here is an implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-and-let</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">e1:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">e2:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e1</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e2</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">The main point of <span class="RktSym">my-and-let</span>, though, is that if the second expression
is evaluated, it is evaluated in an environment where the identifier is bound to
the value of the first expression. Let&rsquo;s put that information in the shape of
<span class="RktSym">my-and-let</span>. It requires two changes:
</div><div class="SIntrapara"><ul><li><p>Label the identifier so we can refer to it later. So instead of
<span class="RktCmt">Id</span>, we write <span class="RktCmt">x:Id</span>. The label does not have to be the same as
the name of the pattern variable, but it makes sense to use the same name here.</p></li><li><p>Add an <span class="emph">environment annotation</span> to the second <span class="RktCmt">Expr</span> indicating
that it&rsquo;s in the scope of a variable whose name is whatever actual identifier
<span class="RktCmt">x</span> refers to: <span class="RktCmt">Expr{x}</span>.</p></li></ul></div></p><p><div class="SIntrapara">Here is the updated shape for <span class="RktSym">my-and-let</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-and-let</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x})</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>We can check the implementation: <span class="RktSym">e1</span> does not occur in the scope of
<span class="RktSym">x</span>, and <span class="RktSym">e2</span> does occur in the scope of <span class="RktSym">x</span>.</p><p><div class="SIntrapara">Here is another implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-and-let x:Id Expr Expr{x}) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-and-let</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">e1:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">e2:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e1</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">BAD</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e2</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">This implementation is <span class="emph">wrong</span>, because <span class="RktSym">e1</span> occurs in the scope of
<span class="RktSym">x</span>, but it should not.</div></p><p><div class="SIntrapara">Here is another version:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-and-let x:Id Expr Expr{x}) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-and-let</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">e1:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">e2:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktSym">e1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>This implementation is good (although more complicated than unnecessary),
because <span class="RktSym">e1</span> no longer occurs in the scope of <span class="RktSym">x</span>. But what about
<span class="RktSym">tmp</span>? Because of hygiene, the definition of <span class="RktSym">tmp</span> introduced by
the macro is not visible to <span class="RktSym">e1</span>. (To be clear, it would be <span class="emph">wrong</span>
to write <span class="RktCmt">Expr{tmp}</span> for the shape of the first expression.)</p><blockquote class="SubFlow"><p><div class="SIntrapara"><a name="(exercise._basic~3aif-let)"></a><span style="font-weight: bold">Exercise&#160;5: </span>Generalize <span class="RktSym">my-and-let</span> to
<span class="RktSym">my-if-let</span>, which takes an extra expression argument which is the
macro&rsquo;s result if the condition is false. The macro should have the following
shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-if-let</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x}</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Double-check your solution to make sure it follows the scoping specified by the
shape.</div></p></blockquote><h4>3.5<tt>&nbsp;</tt><a name="(part._basic-type)"></a>Expressions, Types, and Contracts</h4><p><div class="SIntrapara">Let&rsquo;s design the macro <span class="RktSym">my-match-pair</span>, which takes an expression to
destructure, two identifiers to bind as variables, and a result expression. Here
are some examples:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">ns</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3c%29%29" class="RktValLink" data-pltdoc="x">&lt;</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ns</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect #t</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">p</span><span class="hspace">&nbsp;</span><span class="RktVal">"hello world"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">tag</span><span class="hspace">&nbsp;</span><span class="RktSym">content</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._format%29%29" class="RktValLink" data-pltdoc="x">format</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"&lt;~a&gt;~a&lt;/~a&gt;"</span><span class="hspace">&nbsp;</span><span class="RktSym">tag</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/strings.html#%28def._%28%28lib._racket%2Fstring..rkt%29._string-join%29%29" class="RktValLink" data-pltdoc="x">string-join</a></span><span class="hspace">&nbsp;</span><span class="RktSym">content</span><span class="hspace">&nbsp;</span><span class="RktVal">" "</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">tag</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect "&lt;p&gt;hello world&lt;/p&gt;"</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here is one shape we could write for <span class="RktSym">my-match-pair</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">xs:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x,xs})</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here&rsquo;s an implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-match-pair</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">xs:id</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">pair-v</span><span class="hspace">&nbsp;</span><span class="RktSym">pair</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">xs</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Note that we introduce a <span class="emph">temporary variable</span> (or <span class="emph">auxiliary
variable</span>) named <span class="RktSym">pair-v</span> to avoid evaluating the <span class="RktSym">pair</span>
expression twice.</p><p><div class="SIntrapara">We could add more information to the shape. The macro expects the first argument
to be a pair, and whatever types of values the pair contains become the types of
the identifiers:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr[(cons</span><span class="hspace">&nbsp;</span><span class="RktCmt">T1</span><span class="hspace">&nbsp;</span><span class="RktCmt">T2)]</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">xs:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x:T1,xs:T2})</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">I&rsquo;ve written <span class="RktCmt">Expr[(cons T1 T2)]</span> for the shape of expressions of type
<span class="RktCmt">(cons T1 T2)</span>, where the type <span class="RktCmt">(cons T1 T2)</span> is the type of all pairs
(values made with the <span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span> constructor) whose first component has type
<span class="RktCmt">T1</span> and whose second component has type <span class="RktCmt">T2</span>. The second expression&rsquo;s
environment annotation includes the types of the variables. This macro shape is
polymorphic; there is an implicit <span class="RktCmt">forall (T1, T2)</span> at the beginning of
the declaration.</div></p><p><div class="SIntrapara">The result of the macro is the result of the second expression, so the type of
the macro is the same as the type of the second expression. We could add that
to the shape too:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr[(cons</span><span class="hspace">&nbsp;</span><span class="RktCmt">T1</span><span class="hspace">&nbsp;</span><span class="RktCmt">T2)]</span><span class="hspace">&nbsp;</span><span class="RktCmt">x:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">xs:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{x:T1,xs:T2}[R])</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr[R]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Now the second <span class="RktCmt">Expr</span> has both a environment annotation and a type
annotation.</div></p><p>When I say &ldquo;type&rdquo; here, I&rsquo;m not talking about Typed Racket or some other typed
language implemented in Racket, nor do I mean that there&rsquo;s a super-secret type
checker hidden somewhere in Racket next to a flight simulator. By &ldquo;type&rdquo; I
mean a semi-formal, unchecked description of expressions and macros that
manipulate them. In this case, the shape declaration for <span class="RktSym">my-match-pair</span>
warns the user that the first argument must produce a pair. If it doesn&rsquo;t, the
user has failed their obligations, and the macro may do bad things.</p><p>Of course, given human limitations, we would prefer the macro not to do bad
things. Ideally, the macro definition and macro uses could be statically checked
for compliance with shape declarations, but Racket does not not implement such a
checker for macros. (It&rsquo;s complicated.) At least, though, the macro enforce
approximations of the types of expression arguments using <span class="emph">contracts</span>.</p><p>Use the <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28def._%28%28lib._syntax%2Fparse..rkt%29._expr%2Fc%29%29" class="RktValLink" data-pltdoc="x">expr/c</a></span> syntax class for a pattern variable whose shape is
<span class="RktCmt">Expr[Type]</span> when <span class="RktCmt">Type</span> has a useful contract approximation. In this
example, the type <span class="RktCmt">(cons T1 T2)</span> has a useful contract approximation
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span>, but there is no useful contract for the type <span class="RktCmt">R</span>. The
<span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28def._%28%28lib._syntax%2Fparse..rkt%29._expr%2Fc%29%29" class="RktValLink" data-pltdoc="x">expr/c</a></span> syntax class takes an argument, so you cannot use the
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">:</span><span class="hspace"></span></span> notation; you must use <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7evar%29%29" class="RktStxLink" data-pltdoc="x">~var</a></span> or <span class="RktPn">#:declare</span>
instead. The argument is a syntax object representing the contract to apply to
the expression. (It is <span class="RktRdr">#'</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span> instead of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span> because the
contract check is performed at run time.) In the syntax template, use the
<span class="RktSym">c</span> ("contracted") <span class="emph">attribute</span> of the pattern variable to get the
expression with a contract-checking wrapper. Here&rsquo;s the contract-checked version
of the macro:</p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-match-pair Expr[(cons T1 T2)] x:Id xs:Id Expr{x:T1,xs:T2}[R]) : Expr[R]</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-match-pair</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7evar%29%29" class="RktStxLink" data-pltdoc="x">~var</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28def._%28%28lib._syntax%2Fparse..rkt%29._expr%2Fc%29%29" class="RktValLink" data-pltdoc="x">expr/c</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">xs:id</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">pair-v</span><span class="hspace">&nbsp;</span><span class="RktSym">pair.c</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Important: pair.c, not pair</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">xs</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Here&rsquo;s the implementation using <span class="RktPn">#:declare</span> instead of <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7evar%29%29" class="RktStxLink" data-pltdoc="x">~var</a></span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-match-pair</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair</span><span class="hspace">&nbsp;</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">xs:id</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:declare</span><span class="hspace">&nbsp;</span><span class="RktSym">pair</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28def._%28%28lib._syntax%2Fparse..rkt%29._expr%2Fc%29%29" class="RktValLink" data-pltdoc="x">expr/c</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">pair-v</span><span class="hspace">&nbsp;</span><span class="RktSym">pair.c</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Important: pair.c, not pair</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">xs</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">pair-v</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Now calling <span class="RktSym">my-match-pair</span> raises a contract violation if the first
expression does not produce a pair. For example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-match-pair</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">not-a-pair</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">ns</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">my-match-pair: contract violation</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: pair?</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">given: 'not-a-pair</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">in: pair?</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">macro argument contract</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">contract from: top-level</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">blaming: top-level</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">(assuming the contract is correct)</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">at: eval:32:0</span></p></td></tr></table></blockquote></div></p><blockquote class="SubFlow"><p><a name="(exercise._basic~3amy-when-contract)"></a><span style="font-weight: bold">Exercise&#160;6: </span>Modify the <span class="RktSym">my-when</span> macro to
check that the condition expression produces a boolean value. (Note: this is not
idiomatic for Racket conditional macros).</p></blockquote><h4>3.6<tt>&nbsp;</tt><a name="(part._basic-expr-uses)"></a>Uses of Expressions</h4><p><div class="SIntrapara">In general, what can a macro do with an expression (<span class="RktCmt">Expr</span>)?
</div><div class="SIntrapara"><ul><li><p>It can use the value (or values) that the expression evaluates to. For
example, the behavior of the <span class="RktSym">my-when</span> macro depends on the value that
its first expression produces.</p></li><li><p>It can determine whether the expression is evaluated or when the
expression is evaluated. The <span class="RktSym">my-when</span> example determines whether to
evaluate its second expression. The standard <span class="RktSym">delay</span> macro is a classic
example of controlling when an expression is evaluated.</p></li><li><p>It can change what dynamic context the expression is evaluated within. For
example, a macro could use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/parameters.html#%28form._%28%28lib._racket%2Fprivate%2Fmore-scheme..rkt%29._parameterize%29%29" class="RktStxLink" data-pltdoc="x">parameterize</a></span> to evaluate the expression in a
context with different values for some parameters.</p></li><li><p>It can change the static context the expression is evaluated
within. Mainly, this means putting the expression in the scope of additional
bindings, as we did in <span class="RktSym">my-and-let</span> and <span class="RktSym">my-match-pair</span>.</p></li></ul></div></p><p>There are some restrictions on what macros can do and should do with expressions:</p><ul><li><p><span style="font-weight: bold">A macro cannot get the value of the expression at compile time.</span> The
expression represents computation that will occur later, at run time, perhaps on
different machines, perhaps many times with different values in the run-time
environment. A macro can only interact with an expression&rsquo;s value by producing
code to process the value at run time.</p></li><li><p><span style="font-weight: bold">A macro must not look at the contents of the expression itself.</span>
Expressions are macro-extensible, so there is no grammar to guide case
analysis. Interpreting expressions is the macro expander&rsquo;s business, so don&rsquo;t
try it yourself. The macro expander is complicated, and if you attempt to
duplicate its work &ldquo;just a little&rdquo;, you are likely to make unjustified
assumptions and get it wrong. For example, an expression consisting of a
self-quoting datum is not necessarily a constant, or even free of side effects;
it might have a nonstandard <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._~23~25datum%29%29" class="RktStxLink" data-pltdoc="x">#%datum</a></span> binding, which could give it any
behavior at all. Likewise, a plain identifier is not necessarily a variable
reference; it might be an identifier macro, or it might have a nonstandard
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/__top.html#%28form._%28%28quote._~23~25kernel%29._~23~25top%29%29" class="RktStxLink" data-pltdoc="x">#%top</a></span> binding.</p><p>In later sections (FIXME-REF), we&rsquo;ll talk about how to cooperate with
the macro expander to do case analysis of expressions and other forms.</p></li><li><p>In general, a macro should not duplicate an argument expression. That is,
the expression should occur exactly once in the macro&rsquo;s expansion. Duplicating
expressions leads to expanding the same code multiple times, which can lead to
slow compilation and bloated compiled code. The increases to both time and code
size are potentially exponential, if duplicated expressions themselves contain
macros that duplicate expressions and so on.</p><p>If you need to refer to an expression&rsquo;s value multiple times, bind it to a
temporary variable. If you need to evaluate the same expression multiple times,
then bind a temporary variable to a thunk containing the expression and then
apply the thunk multiple times.</p><p>One exception to this rule is if the macro knows that the expression is
&ldquo;simple&rdquo;, like a variable reference or quoted constant, because the macro is
private and all of its use sites can be inspected. We&rsquo;ll discuss this case in
<a href="#%28part._simple-expr%29" data-pltdoc="x">Helper Macros and Simple Expressions</a>.</p></li><li><p>In general, a macro should evaluate expressions in the same order that
they appear (that is, &ldquo;left to right&rdquo;), unless it has a reason to do
otherwise.</p><p>In Racket information generally flows from left to right, and the interpretation
of later terms can depend on earlier terms. For example, <span class="RktSym">my-when</span> uses
the value of its first (that is, left-most) expression argument to decide
whether to evaluate its second (that is, right-most) expression. It would be
non-idiomatic syntax design to put the condition expression second and the
result expression first.</p><p>Similarly, the scope of an identifier is generally somewhere to the right of the
identifier itself. For example, in <span class="RktSym">my-match-pair</span>, the identifiers are
in scope in the following expression. If we swapped <span class="RktSym">my-match-pair</span>&rsquo;s
expressions, so it had the shape <span class="RktCmt">(my-match-pair Expr{x,xs} x:Id xs:Id
Expr)</span>, that would not be idiomatic.</p></li></ul><p>The same principles apply to <span class="RktCmt">Body</span> terms as well.</p><h3>4<tt>&nbsp;</tt><a name="(part._compound-shapes)"></a>Compound Shapes</h3><p>This section introduces compound shapes, including list shapes and ellipsis
shapes. It discusses several implementation strategies for macros consuming
ellipsis shapes.</p><h4>4.1<tt>&nbsp;</tt><a name="(part._list-shapes)"></a>List Shapes</h4><p>The main kind of <span class="emph">compound shape</span> is the <span class="emph">list shape</span>, describing list
terms of fixed or varying length. Actually, we have already been using list
shapes to describe a macro&rsquo;s arguments: a macro transformer function in fact
receives exactly one argument, corresponding to the whole macro-use
term. Typically, that is a list term with the macro identifier first and the
arguments making up the rest of the list.</p><p>We can add additional levels of grouping to the arguments. For example, here&rsquo;s a
variant of <span class="RktSym">my-and-let</span> that groups the identifier with the expression
that provides its value:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-and-let2 [x:Id Expr] Expr{x}) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-and-let2</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">x:id</span><span class="hspace">&nbsp;</span><span class="RktSym">e1:expr</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">e2:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e1</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e2</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>By itself, though, this change isn&rsquo;t very interesting. The real utility of list
shapes (and patterns, and templates) is in their interaction with enumeration
shapes and ellipses. We&rsquo;ll discuss ellipses now as a special case and discuss
enumeration shapes later.</p><h4>4.2<tt>&nbsp;</tt><a name="(part._ellipses-simple)"></a>Ellipses with Simple Shapes</h4><p>Ellipses mean zero or more repetitions of the preceding shape, pattern, or
template. They are like the star (*) operator in regular expressions. For
example, here is the shape of Racket&rsquo;s <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._and%29%29" class="RktStxLink" data-pltdoc="x">and</a></span> macro:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(and</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote><p><div class="SIntrapara">How can we implement our own macro with this shape? There are three basic
implementation strategies:
</div><div class="SIntrapara"><ul><li><p>recursive macro</p></li><li><p>recursive run-time helper function</p></li><li><p>recursive compile-time helper function</p></li></ul></div></p><h5>4.2.1<tt>&nbsp;</tt><a name="(part._ellipses-rec-macro)"></a>Recursive Macros</h5><p><div class="SIntrapara">The first strategy is to write a macro that does case analysis and explicit
recursion &#8212;<wbr></wbr> that is, the macro expands into another use of itself. Here is a
recursive implementation of <span class="RktSym">my-and</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-and Expr ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-and</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktVal">#t</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">e1:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">e:expr</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">e1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-and</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>(This isn&rsquo;t quite like Racket&rsquo;s <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._and%29%29" class="RktStxLink" data-pltdoc="x">and</a></span>, which returns the value of the
last expression if all previous expressions were true, and it evaluates the last
expression in tail position. But it&rsquo;s close enough to illustrate ellipses and
recursive macros.)</p><p><div class="SIntrapara">This macro divides one shape into two patterns: zero expressions or at least one
expression. If we use <span class="RktSym">my-and</span> as follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">my-and</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></div><div class="SIntrapara">then the first pattern fails to match, but the second pattern matches with
<span class="RktSym">e1</span> = <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span> and <span class="RktSym">e</span><span class="stt"> </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span> = <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="stt"> </span><span class="RktVal">3</span><span class="RktPn">)</span>. Note that <span class="RktSym">e</span> doesn&rsquo;t match a single term; it matches a sequence of
terms, and when we use <span class="RktSym">e</span> in the template, we must follow it with
ellipses. One expansion step rewrites this program to the following:</div></p><blockquote class="SCodeFlow"><p>&#8658;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-and</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span></p></blockquote><p>Where once there were three, now there are only two expressions in the remaining
call to <span class="RktSym">my-and</span>. Subsequent steps rewrite that to one, and then none,
and then <span class="RktSym">my-and</span>&rsquo;s base case matches and it disappears entirely:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>&#8658;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-and</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span></td></tr><tr><td>&#8658;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-and</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span></td></tr><tr><td>&#8658;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span></td></tr></table></blockquote><h5>4.2.2<tt>&nbsp;</tt><a name="(part._ellipses-rt-helper)"></a>Recursive Run-time Helper Function</h5><p>Another implementation strategy is to expand into another variable-arity form or
function. For example, here is another definition of <span class="RktSym">my-and</span> that relies
on Racket&rsquo;s <span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._andmap%29%29" class="RktValLink" data-pltdoc="x">andmap</a></span> function, &ldquo;thunking&rdquo; to delay evaluation, and the
variable-arity <span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span> function:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-and Expr ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-and</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">e:expr</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._andmap%29%29" class="RktValLink" data-pltdoc="x">andmap</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">thunk</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">thunk</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p><div class="SIntrapara">Note the use of <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">e</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span> in the template. The pattern variable
<span class="RktSym">e</span> occurred in front of ellipses in the pattern, so it must be used in
front of ellipses in the template. But the term before the ellipses in the
template isn&rsquo;t just <span class="RktSym">e</span>, it is <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">e</span><span class="RktPn">)</span>. This
<span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">)</span><span class="stt"> </span><span style="color: lightgray">&#9251;</span><span class="RktPn">)</span> wrapper gets copied for every instance of <span class="RktSym">e</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">my-and</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span></td></tr><tr><td>&#8658;</td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._andmap%29%29" class="RktValLink" data-pltdoc="x">andmap</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">thunk</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">thunk</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">That is, ellipses in a syntax template act like an implicit <span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._map%29%29" class="RktValLink" data-pltdoc="x">map</a></span> over
the pattern variables.</div></p><p>For a frequently-used, simple macro like <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._and%29%29" class="RktStxLink" data-pltdoc="x">and</a></span>, this might not be a good
implementation because of run-time overhead, but for other macros this kind of
implementation might be reasonable.</p><blockquote class="SubFlow"><p><span style="font-weight: bold">Lesson: </span><span style="font-style: italic">Many macros can be decomposed into two parts: a compile-time part that
adds <span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span> wrappers to handle scoping and delayed evaluation, and a
run-time part that implements the computation and behavior of the macro.</span></p></blockquote><h5>4.2.3<tt>&nbsp;</tt><a name="(part._ellipses-ct-helper)"></a>Recursive Compile-time Helper Function</h5><p>The final strategy is to use a compile-time helper function, which handles the
recursion either directly or indirectly. Here is another implementation of
<span class="RktSym">my-and</span>, where the macro itself is not recursive but the transformer
uses a recursive compile-time helper function:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">my-and-helper : (Listof Syntax[Expr]) -&gt; Syntax[Expr]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-and-helper</span><span class="hspace">&nbsp;</span><span class="RktSym">exprs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">exprs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#`</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#,</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">exprs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#,</span><span class="RktPn">(</span><span class="RktSym">my-and-helper</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">exprs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-and Expr ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-and</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">e:expr</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-and-helper</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._syntax-~3elist%29%29" class="RktValLink" data-pltdoc="x">syntax-&gt;list</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>The compile-time <span class="RktSym">my-and-helper</span> function takes a list of syntax objects
representing expressions and combines them into a single syntax object
representing an expression. Whenever possible, annotate the <span class="RktCmt">Syntax</span> type
with the shape of the term that the syntax object represents: for example,
<span class="RktCmt">Syntax[Expr]</span>, <span class="RktCmt">Syntax[(Expr ...)]</span>, etc. The function uses
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fqqstx..rkt%29._quasisyntax%29%29" class="RktStxLink" data-pltdoc="x">quasisyntax</a></span> (which has the reader abbreviation <span class="RktInBG"><span class="hspace"></span><span class="RktIn">#`</span><span class="hspace"></span></span>) to create
syntax from a template that allows <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fqqstx..rkt%29._unsyntax%29%29" class="RktStxLink" data-pltdoc="x">unsyntax</a></span> escapes (<span class="RktInBG"><span class="hspace"></span><span class="RktIn">#,</span><span class="hspace"></span></span>) to
compute sub-terms. The macro calls the helper with a list of syntax
objects. First it uses ellipses to form the syntax list containing all of the
argument expressions: <span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">e</span><span class="stt"> </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span>. This value has the type
<span class="RktCmt">Syntax[(Expr ...)]</span>. Then it calls <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._syntax-~3elist%29%29" class="RktValLink" data-pltdoc="x">syntax-&gt;list</a></span>, which unwraps
the syntax list into a list of syntax &#8212;<wbr></wbr> in this case, specifically, a
<span class="RktCmt">(Listof Syntax[Expr])</span>.</p><p>Because it is defined in the transformer environment (or &ldquo;at phase 1&rdquo;), you
cannot directly call <span class="RktSym">my-and-helper</span> at the REPL to explore its
behavior. But you can call it using <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/macro-testing.html#%28form._%28%28lib._syntax%2Fmacro-testing..rkt%29._phase1-eval%29%29" class="RktStxLink" data-pltdoc="x">phase1-eval</a></span> special form. Keep in
mind that the whole argument to <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/macro-testing.html#%28form._%28%28lib._syntax%2Fmacro-testing..rkt%29._phase1-eval%29%29" class="RktStxLink" data-pltdoc="x">phase1-eval</a></span> is a compile-time
expression, so you cannot refer to any run-time variables. Also,
<span class="RktSym"><a href="https://docs.racket-lang.org/syntax/macro-testing.html#%28form._%28%28lib._syntax%2Fmacro-testing..rkt%29._phase1-eval%29%29" class="RktStxLink" data-pltdoc="x">phase1-eval</a></span> must be told how to convert the phase-1 (compile-time)
answer into an expression to produce a phase-0 (run-time) value. When the result
type is syntax, use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/Syntax_Quoting__quote-syntax.html#%28form._%28%28quote._~23~25kernel%29._quote-syntax%29%29" class="RktStxLink" data-pltdoc="x">quote-syntax</a></span> if you want to preserve the
syntax-nature of the result; otherwise, use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span>. For example:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/macro-testing.html#%28form._%28%28lib._syntax%2Fmacro-testing..rkt%29._phase1-eval%29%29" class="RktStxLink" data-pltdoc="x">phase1-eval</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-and-helper</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:quote</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Syntax_Quoting__quote-syntax.html#%28form._%28%28quote._~23~25kernel%29._quote-syntax%29%29" class="RktStxLink" data-pltdoc="x">quote-syntax</a></span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">#&lt;syntax:eval:11:0 (if (odd? 1) (if (even? 2) #t #f) #f)&gt;</span></p></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/macro-testing.html#%28form._%28%28lib._syntax%2Fmacro-testing..rkt%29._phase1-eval%29%29" class="RktStxLink" data-pltdoc="x">phase1-eval</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-and-helper</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:quote</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'(if (odd? 1) (if (even? 2) #t #f) #f)</span></p></td></tr></table></blockquote><p><div class="SIntrapara">The compile-time helper function could be written more concisely using
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._foldr%29%29" class="RktValLink" data-pltdoc="x">foldr</a></span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">my-and-helper : (Listof Syntax[Expr]) -&gt; Syntax[Expr]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-and-helper</span><span class="hspace">&nbsp;</span><span class="RktSym">exprs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._foldr%29%29" class="RktValLink" data-pltdoc="x">foldr</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">expr</span><span class="hspace">&nbsp;</span><span class="RktSym">rec-code</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#`</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#,</span><span class="RktSym">expr</span><span class="hspace">&nbsp;</span><span class="RktRdr">#,</span><span class="RktSym">rec-code</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktVal">#t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">exprs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Or we could just use the body of the compile-time helper function (now that we
have eliminated the recursion) directly in the macro:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-and Expr ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-and-helper</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">e:expr</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._foldr%29%29" class="RktValLink" data-pltdoc="x">foldr</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">expr</span><span class="hspace">&nbsp;</span><span class="RktSym">rec-code</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#`</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#,</span><span class="RktSym">expr</span><span class="hspace">&nbsp;</span><span class="RktRdr">#,</span><span class="RktSym">rec-code</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktVal">#t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._syntax-~3elist%29%29" class="RktValLink" data-pltdoc="x">syntax-&gt;list</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">We can still use <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/macro-testing.html#%28form._%28%28lib._syntax%2Fmacro-testing..rkt%29._phase1-eval%29%29" class="RktStxLink" data-pltdoc="x">phase1-eval</a></span> to explore more complicated compile-time
expressions:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/macro-testing.html#%28form._%28%28lib._syntax%2Fmacro-testing..rkt%29._phase1-eval%29%29" class="RktStxLink" data-pltdoc="x">phase1-eval</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._foldr%29%29" class="RktValLink" data-pltdoc="x">foldr</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">expr</span><span class="hspace">&nbsp;</span><span class="RktSym">rec-code</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#`</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#,</span><span class="RktSym">expr</span><span class="hspace">&nbsp;</span><span class="RktRdr">#,</span><span class="RktSym">rec-code</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktVal">#t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._syntax-~3elist%29%29" class="RktValLink" data-pltdoc="x">syntax-&gt;list</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'(if (odd? 1) (if (even? 2) #t #f) #f)</span></p></td></tr></table></blockquote></div></p><h4>4.3<tt>&nbsp;</tt><a name="(part._ellipses-compound)"></a>Ellipses with Compound Shapes</h4><p>Ellipses can also be used with compound shapes. For example, here is the shape
of a simplified version of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span> (it doesn&rsquo;t support <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span> and
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span> clauses):</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-cond</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Here&rsquo;s a recursive implementation:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond [Expr Expr] ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition1:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result1:expr</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">result1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p><div class="SIntrapara">Here is an implementation using a recursive run-time helper function:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond [Expr Expr] ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">my-cond-helper</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">my-cond-helper : (Listof (-&gt; Any)) (Listof (-&gt; X)) -&gt; X</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">PRE: condition-thunks and result-thunks have the same length</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond-helper</span><span class="hspace">&nbsp;</span><span class="RktSym">condition-thunks</span><span class="hspace">&nbsp;</span><span class="RktSym">result-thunks</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._pair~3f%29%29" class="RktValLink" data-pltdoc="x">pair?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition-thunks</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition-thunks</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">result-thunks</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond-helper</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition-thunks</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">result-thunks</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Here is an implementation using a recursive helper <span class="emph">macro</span> &#8212;<wbr></wbr> Racket&rsquo;s
variadic <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._or%29%29" class="RktStxLink" data-pltdoc="x">or</a></span> macro. It also relies on fact that <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._and%29%29" class="RktStxLink" data-pltdoc="x">and</a></span> and
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._or%29%29" class="RktStxLink" data-pltdoc="x">or</a></span> treat any value other than <span class="RktVal">#f</span> as true, and return that
specific true value as their result when appropriate.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond [Expr Expr] ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._or%29%29" class="RktStxLink" data-pltdoc="x">or</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._and%29%29" class="RktStxLink" data-pltdoc="x">and</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><blockquote class="SubFlow"><p><div class="SIntrapara"><a name="(exercise._compound~3acond-ct)"></a><span style="font-weight: bold">Exercise&#160;7: </span>Implement <span class="RktSym">my-cond</span> using a
compile-time helper function that takes a list of condition expressions and a
list of result expressions:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">my-cond-helper</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">(Listof</span><span class="hspace">&nbsp;</span><span class="RktCmt">Syntax[Expr])</span><span class="hspace">&nbsp;</span><span class="RktCmt">(Listof</span><span class="hspace">&nbsp;</span><span class="RktCmt">Syntax[Expr])</span><span class="hspace">&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Syntax[Expr]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">PRE:</span><span class="hspace">&nbsp;</span><span class="RktCmt">the</span><span class="hspace">&nbsp;</span><span class="RktCmt">two</span><span class="hspace">&nbsp;</span><span class="RktCmt">lists</span><span class="hspace">&nbsp;</span><span class="RktCmt">of</span><span class="hspace">&nbsp;</span><span class="RktCmt">expressions</span><span class="hspace">&nbsp;</span><span class="RktCmt">have</span><span class="hspace">&nbsp;</span><span class="RktCmt">the</span><span class="hspace">&nbsp;</span><span class="RktCmt">same</span><span class="hspace">&nbsp;</span><span class="RktCmt">length</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Hint: Racket&rsquo;s <span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._foldr%29%29" class="RktValLink" data-pltdoc="x">foldr</a></span> function is variadic.</div></p></blockquote><blockquote class="SubFlow"><p><div class="SIntrapara"><a name="(exercise._compound~3amy-and-let2)"></a><span style="font-weight: bold">Exercise&#160;8: </span>Generalize <span class="RktSym">my-and-let</span> so that
it takes a list of identifier-and-expression clauses. That is, it should have
the following shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-and-let</span><span class="hspace">&nbsp;</span><span class="RktCmt">([Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">The scope of each identifier includes all subsequent clauses and the final
expression. Implement the macro either as a recursive macro or by using a
compile-time helper function.</div></p></blockquote><blockquote class="SubFlow"><p><div class="SIntrapara"><a name="(exercise._compound~3amy-evcase1)"></a><span style="font-weight: bold">Exercise&#160;9: </span>Design a macro <span class="RktSym">my-evcase1</span> with
the following shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-evcase1</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">The macro evaluates its first argument to get the value to match. Then it tries
each clause until one is selected. A clause is selected if its first expression
produces a value equal to the value to match; that clause&rsquo;s second expression is
the result of the macro. If no clause matches, the result is <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span>.</div></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">my-evcase1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin%29%29" class="RktStxLink" data-pltdoc="x">begin</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"got a coin!\n"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">"nickel"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">10</span><span class="hspace">&nbsp;</span><span class="RktVal">"dime"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">25</span><span class="hspace">&nbsp;</span><span class="RktVal">"quarter"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2F%29%29" class="RktValLink" data-pltdoc="x">/</a></span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"infinite money!"</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect print once, result = "quarter"</span></td></tr></table></blockquote></blockquote><h3>5<tt>&nbsp;</tt><a name="(part._defshape)"></a>Shape Definitions</h3><p>This section shows how to define new shapes and their corresponding
syntax classes.</p><p>This section also introduces a shape for simple expressions.</p><h4>5.1<tt>&nbsp;</tt><a name="(part._defshape-def)"></a>Defining New Shapes</h4><p>Consider the shape we&rsquo;ve given to <span class="RktSym">my-cond</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-cond</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote><p>This tells us the structure of <span class="RktSym">my-cond</span>&rsquo;s arguments, but it gives us no
hook upon which to hang a description of the arguments&rsquo; interpretation. Let&rsquo;s
give it a name:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClause</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">--</span><span class="hspace">&nbsp;</span><span class="RktCmt">represent</span><span class="hspace">&nbsp;</span><span class="RktCmt">condition,</span><span class="hspace">&nbsp;</span><span class="RktCmt">result</span><span class="RktMeta"></span></td></tr></table></blockquote><p><div class="SIntrapara">Now when we describe the behavior of <span class="RktSym">my-cond</span>, we can separate out the
structure and interpretation of <span class="RktCmt">CondClause</span>s from the discussion of
<span class="RktSym">my-cond</span> itself.
</div><div class="SIntrapara"><ul><li><p>The <span class="RktSym">my-cond</span> form takes a sequence of <span class="RktCmt">CondClauses</span>, and
that it tries each <span class="RktCmt">CondClause</span> in order until one is selected, and the
result of the <span class="RktSym">my-cond</span> expression is the result of the selected
<span class="RktCmt">CondClause</span>, or <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span> if none was selected.</p></li><li><p>A <span class="RktCmt">CondClause</span> consists of two expressions. The first represents a
condition; if it evaluates to a true value, then the clause is selected. The
second expression determines the clause&rsquo;s result.</p></li></ul></div></p><p>I typically write something like the terse comment above in the source code and
include the longer, more precise version in the documentation.</p><p><div class="SIntrapara">We should also define a syntax class, <span class="RktSym">cond-clause</span>, corresponding to the
new shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">cond-clause</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">condition</span><span class="hspace">&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Expr, Expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">The syntax class has a single <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span> form specifying the structure of
the terms it accepts. The pattern variables are exported from the syntax class
as <span class="emph">syntax-valued attributes</span>. I&rsquo;ve written a comment after the
<span class="RktPn">#:attributes</span> declaration with the shape of each attribute; they both
contain <span class="RktCmt">Expr</span> terms.</div></p><p>My convention is to use capitalized names such as <span class="RktCmt">Expr</span>, <span class="RktCmt">Id</span>, and
<span class="RktCmt">CondClause</span> for shapes and lower-case names such as <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span>,
<span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._id%29%29" class="RktStxLink" data-pltdoc="x">id</a></span>, and <span class="RktSym">cond-clause</span> for syntax classes. Distinguishing them
serves as a reminder that syntax classes represent some but not all of the
meaning of shapes, just like Racket&rsquo;s contracts capture some but not all of the
meaning of types. The syntax class checks that terms have the right structure,
and its attribute names hint at their intended interpretation, but the syntax
class cannot enforce that interpretation.</p><p>We update the macro&rsquo;s shape to refer to the new shape name, and we update the
implementation&rsquo;s pattern to use a pattern variable annotated with the new syntax
class (<span class="RktSym">c:cond-clause</span>). In the template, we refer to the pattern
variable&rsquo;s <span class="emph">attributes</span> defined by the syntax class (<span class="RktSym">c.condition</span>
and <span class="RktSym">c.result</span>).</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond CondClause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c:cond-clause</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c.condition</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">c.result</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>In addition to improved organization, another benefit of defining
<span class="RktSym">cond-clause</span> as a syntax class is that <span class="RktSym">my-cond</span> now
automatically uses <span class="RktSym">cond-clause</span> to help explain syntax errors. For
example:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">eval:9:0: my-cond: expected cond-clause</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">at: 5</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">in: (my-cond 5)</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">#t</span><span class="hspace">&nbsp;</span><span class="RktPn">#:whoops</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">eval:10:0: my-cond: expected expression</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">at: #:whoops</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">in: (my-cond (#t #:whoops))</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">parsing context: </span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">while parsing cond-clause</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">term: (#t #:whoops)</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">location: eval:10:0</span></p></td></tr></table></blockquote><p>In the implementation above, should we also annotate <span class="RktSym">more</span> to check that
all of the arguments are clauses, instead of only checking the first clause at
each step? That is:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond CondClause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c:cond-clause</span><span class="hspace">&nbsp;</span><span class="RktSym">more:cond-clause</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c.condition</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">c.result</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>It can lead to earlier detection of syntax errors and better error messages,
because the error is reported in terms of the original expression the user
wrote, as opposed to one created by the macro for recursion. The cost is that
the syntax-class check is performed again and again on later arguments; the
number of <span class="RktSym">cond-clause</span> checks performed by this version is quadratic in
the number of clauses it originally receives. One solution is to make the public
<span class="RktSym">my-cond</span> macro check all of the clauses and then expand into a private
recursive helper macro that only interprets one clause at a time.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond CondClause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c:cond-clause</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">my-cond*</span><span class="hspace">&nbsp;</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond* CondClause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond*</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c:cond-clause</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c.condition</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">c.result</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond*</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>This tension arises because a syntax class has two purposes: validation and
interpretation. For a single term, validation should precede interpretation, but
if a macro has many arguments (for example, a use of <span class="RktSym">my-cond</span> might have
many <span class="RktCmt">CondClause</span>s), how should we interleave validation and
interpretation of the many terms? One appealing goal is to validate all
arguments before interpreting any of them. Another appealing goal is to only
&ldquo;call&rdquo; a syntax class once per term. Each goal constrains the ways we can
define the syntax class and write the macro; achieving both goals is especially
tricky.</p><p>A related question is this: How much of the task of interpeting a term belongs
to the syntax class versus the macro that uses it? The division of
responsibility between syntax class and macro affects the <span class="emph">interface</span>
between them, and that interface affects how the macro is written. This question
becomes more complicated when we add variants to a syntax class; we discuss the
difficulties and solutions in detail in <a href="#%28part._enum-shapes%29" data-pltdoc="x">Enumerated Shapes</a>.</p><h4>5.2<tt>&nbsp;</tt><a name="(part._defshape-same-diff)"></a>Same Structure, Different Interpretation</h4><p><div class="SIntrapara">Recall <a href="#%28exercise._compound~3amy-evcase1%29" data-pltdoc="x">Exercise&#160;9</a>. The goal was to design a macro
<span class="RktSym">my-evcase1</span> with the following shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-evcase1</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">The exercise&rsquo;s description of the macro&rsquo;s behavior referred to &ldquo;clauses&rdquo;,
which is a hint that we should improve the specification by naming that argument
shape. Let&rsquo;s do that now.</div></p><p>We already have a name for the shape <span class="RktCmt">[Expr Expr]</span>; should we simply
define the shape of <span class="RktSym">my-evcase1</span> in terms of <span class="RktCmt">CondClause</span>? (Perhaps
we should also generalize the name to <span class="RktCmt">ClauseWith2Exprs</span> so it doesn&rsquo;t
seem so tied to <span class="RktSym">my-cond</span>?)</p><p>No. The structure of the two shapes is the same, but the interpretation is
different. Specifically, the first expression of a <span class="RktCmt">CondClause</span> is treated
as a condition, but the first expression of a <span class="RktSym">my-evcase1</span> clause is
treated as a value for equality comparison. Furthermore, the two macros happen
to have the same clause structure now, but if we add features to one or the
other (and we will), they might evolve in different ways. In fact, they are
likely to evolve in different ways <span class="emph">because</span> they have different
interpretations.</p><p><div class="SIntrapara">So let&rsquo;s define a new shape, <span class="RktCmt">EC1Clause</span>, for <span class="RktSym">my-evcase1</span> clauses:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">EC1Clause</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">--</span><span class="hspace">&nbsp;</span><span class="RktCmt">comparison</span><span class="hspace">&nbsp;</span><span class="RktCmt">value,</span><span class="hspace">&nbsp;</span><span class="RktCmt">result</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Here is the corresponding syntax class:</div></p><p><div class="SIntrapara">Now the macro has the shape
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-evcase1</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">EC1Clause</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">One implementation strategy is to use <span class="RktSym">my-cond</span> as a helper macro. Here&rsquo;s
a first attempt that isn&rsquo;t quite right:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-evcase1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">find:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">c:ec1-clause</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Equality.html#%28def._%28%28quote._~23~25kernel%29._equal~3f%29%29" class="RktValLink" data-pltdoc="x">equal?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">find</span><span class="hspace">&nbsp;</span><span class="RktSym">c.comparison</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">c.result</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">These examples illustrate the problem:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-evcase1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin%29%29" class="RktStxLink" data-pltdoc="x">begin</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"got a coin!\n"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">"nickel"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">10</span><span class="hspace">&nbsp;</span><span class="RktVal">"dime"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">25</span><span class="hspace">&nbsp;</span><span class="RktVal">"quarter"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2F%29%29" class="RktValLink" data-pltdoc="x">/</a></span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"infinite money!"</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="RktOut">got a coin!</span></p></td></tr><tr><td><p><span class="RktOut">got a coin!</span></p></td></tr><tr><td><p><span class="RktOut">got a coin!</span></p></td></tr></table></td></tr><tr><td><p><span class="RktRes">"quarter"</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">coins</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">25</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">get-coin</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin0%29%29" class="RktStxLink" data-pltdoc="x">begin0</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">coins</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/set_.html#%28form._%28%28quote._~23~25kernel%29._set%21%29%29" class="RktStxLink" data-pltdoc="x">set!</a></span><span class="hspace">&nbsp;</span><span class="RktSym">coins</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">coins</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-evcase1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">get-coin</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">"nickel"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">10</span><span class="hspace">&nbsp;</span><span class="RktVal">"dime"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">25</span><span class="hspace">&nbsp;</span><span class="RktVal">"quarter"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2F%29%29" class="RktValLink" data-pltdoc="x">/</a></span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"infinite money!"</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktErr">/: division by zero</span></p></td></tr></table></blockquote></div><div class="SIntrapara">The initial expression is re-evaluated for every comparison, which is
problematic if the expression has side-effects.</div></p><p><div class="SIntrapara">Here is a fixed implementation that uses a temporary variable to hold the value
of the first expression:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-evcase1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">find:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">c:ec1-clause</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktSym">find</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Equality.html#%28def._%28%28quote._~23~25kernel%29._equal~3f%29%29" class="RktValLink" data-pltdoc="x">equal?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktSym">c.comparison</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">c.result</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Now the examples behave as expected:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-evcase1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin%29%29" class="RktStxLink" data-pltdoc="x">begin</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"got a coin!\n"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">"nickel"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">10</span><span class="hspace">&nbsp;</span><span class="RktVal">"dime"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">25</span><span class="hspace">&nbsp;</span><span class="RktVal">"quarter"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2F%29%29" class="RktValLink" data-pltdoc="x">/</a></span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"infinite money!"</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktOut">got a coin!</span></p></td></tr><tr><td><p><span class="RktRes">"quarter"</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">coins</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">25</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">get-coin</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin0%29%29" class="RktStxLink" data-pltdoc="x">begin0</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktSym">coins</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/set_.html#%28form._%28%28quote._~23~25kernel%29._set%21%29%29" class="RktStxLink" data-pltdoc="x">set!</a></span><span class="hspace">&nbsp;</span><span class="RktSym">coins</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">coins</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-evcase1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">get-coin</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">"nickel"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">10</span><span class="hspace">&nbsp;</span><span class="RktVal">"dime"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">25</span><span class="hspace">&nbsp;</span><span class="RktVal">"quarter"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2F%29%29" class="RktValLink" data-pltdoc="x">/</a></span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"infinite money!"</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">"quarter"</span></p></td></tr></table></blockquote></div></p><blockquote class="SubFlow"><p><a name="(exercise._defshape-test)"></a><span style="font-weight: bold">Exercise&#160;10: </span>Turn the examples above into test cases for
<span class="RktSym">my-evcase1</span>. Check that the tests fail on the original version of the
macro and succeed on the fixed version.</p><p><div class="SIntrapara">The <span class="RktSym">catch-output</span> macro from <a href="#%28exercise._basic~3acatch-output%29" data-pltdoc="x">Exercise&#160;3</a> and
<a href="#%28part._basic-hygiene2%29" data-pltdoc="x">Proper Lexical Scoping, Part 2</a> is not quite enough to express these tests
conveniently. Write a more general helper macro with the following shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(result+output</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr[R])</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr[(list</span><span class="hspace">&nbsp;</span><span class="RktCmt">R</span><span class="hspace">&nbsp;</span><span class="RktCmt">String)]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and use that to express your tests.</div></p></blockquote><h4>5.3<tt>&nbsp;</tt><a name="(part._simple-expr)"></a>Helper Macros and Simple Expressions</h4><p>Recall the implementation strategies for handling ellipsis shapes from
<a href="#%28part._ellipses-simple%29" data-pltdoc="x">Ellipses with Simple Shapes</a>. The first strategy was to write a recursive
macro. Is it possible to implement <span class="RktSym">my-evcase1</span> using that strategy?</p><p>No. It is not possible to implement <span class="RktSym">my-evcase1</span> as a recursive macro,
according to the shape we&rsquo;ve given it, while guaranteeing that we evaluate the
initial expression once. Compare this with fact that some list functions cannot
be written purely as structural recursive functions. The <span class="RktSym">average</span>
function is a good example: it can only be expressed by combining or adjusting
the results of one or more structurally recursive helper functions.</p><p>We can, however, implement <span class="RktSym">my-evcase1</span> using a recursive helper
macro. In fact, we&rsquo;ve done that in the previous implementation, by using
<span class="RktSym">my-cond</span>. But let&rsquo;s try a different implementation using a recursive
macro that has a shape that is similar to, although not identical to, that of
<span class="RktSym">my-evcase1</span>. In particular, it is worth talking about the shape involved
in the interface between the main, public macro and its private helper.</p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-evcase1 Expr EC1Clause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-evcase1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">find:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">c:ec1-clause</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktSym">find</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-evcase1*</span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">So, what is the shape of the helper macro, <span class="RktSym">my-evcase1*</span>?</div></p><p><div class="SIntrapara">We could describe <span class="RktSym">my-evcase1*</span> with the following shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-evcase1*</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">EC1Clause</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">but that&rsquo;s the same shape as <span class="RktSym">my-evcase1</span>, so if we&rsquo;re using the shapes
to guide our design &#8212;<wbr></wbr> specifically, our implementation options &#8212;<wbr></wbr> we have not
made any progress. The point of <span class="RktSym">my-evcase1*</span> is that its first argument
is a simple variable reference, not any arbitrary expression whose evaluation
might be costly or involve side effects. Let&rsquo;s reflect that in the shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-evcase1*</span><span class="hspace">&nbsp;</span><span class="RktCmt">SimpleExpr</span><span class="hspace">&nbsp;</span><span class="RktCmt">EC1Clause</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>The <span class="RktCmt">SimpleExpr</span> shape is like <span class="RktCmt">Expr</span>, except that it only contains
expressions that we are willing to duplicate. That is, the expansion of the
expression is simple and small, and the evaluation of the expression is trivial
and does not involve side effects. Acceptable expressions include quoted
constants and variable references. Usually, we also expect simple expressions to
be constant, so a variable reference should be to a fresh local variable that is
never mutated. Depending on the situation, there might be other expressions that
we would accept as simple.</p><p>There is no separate syntax class for <span class="RktCmt">SimpleExpr</span>; just use <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span>
or omit the syntax class annotation. It is infeasible to <span class="emph">check</span> whether an
expression is simple; instead, you should only make private macros accept
<span class="RktCmt">SimpleExpr</span> arguments, and you should check that all of the public macros
that call them pass appropriate expressions.</p><p>In this example, let&rsquo;s assume that <span class="RktSym">my-evcase1*</span> is private and only
<span class="RktSym">my-evcase</span> calls it. The initial expression that <span class="RktSym">my-evcase</span>
gives to the helper is a local variable reference, which is simple.</p><p><div class="SIntrapara">Here is a recursive implementation of <span class="RktSym">my-evcase1*</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-evcase1* SimpleExpr EC1Clause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-evcase1*</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktSym">c:ec1-clause</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Equality.html#%28def._%28%28quote._~23~25kernel%29._equal~3f%29%29" class="RktValLink" data-pltdoc="x">equal?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktSym">c.comparison</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">c.result</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-evcase1*</span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Note that the second clause duplicates the <span class="RktSym">tmp</span> argument.</p><h3>6<tt>&nbsp;</tt><a name="(part._enum-shapes)"></a>Enumerated Shapes</h3><p>This section introduces enumerated shapes &#8212;<wbr></wbr> that is, shapes with multiple
variants. An enumerated shape poses a problem in defining the interface between
the corresponding syntax class and the macro that uses it. This section
discusses several strategies for defining this interface.</p><h4>6.1<tt>&nbsp;</tt><a name="(part._enum-shapes-def)"></a>Defining Enumerated Shapes</h4><p>In the previous section, we extracted the definition of <span class="RktCmt">CondClause</span> from
the shape of the <span class="RktSym">my-cond</span> macro, and we defined a syntax class
<span class="RktSym">cond-clause</span> corresponding to the shape.</p><p>Now let&rsquo;s extend <span class="RktCmt">CondClause</span> with another <span class="emph">variant</span> that allows the
clause&rsquo;s result to depend on the (true) value produced by the condition. This is
similar to the <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span> clause form that Racket&rsquo;s <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span> macro
supports, but we&rsquo;ll use a keyword, <span class="RktPn">#:apply</span>, to distinguish this form of
clause for <span class="RktSym">my-cond</span>. Here is the updated shape definition:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClause</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">--</span><span class="hspace">&nbsp;</span><span class="RktCmt">represents</span><span class="hspace">&nbsp;</span><span class="RktCmt">condition,</span><span class="hspace">&nbsp;</span><span class="RktCmt">result</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">#:apply</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">--</span><span class="hspace">&nbsp;</span><span class="RktCmt">represents</span><span class="hspace">&nbsp;</span><span class="RktCmt">condition,</span><span class="hspace">&nbsp;</span><span class="RktCmt">function</span><span class="hspace">&nbsp;</span><span class="RktCmt">from</span><span class="hspace">&nbsp;</span><span class="RktCmt">condition</span><span class="hspace">&nbsp;</span><span class="RktCmt">to</span><span class="hspace">&nbsp;</span><span class="RktCmt">result</span><span class="RktMeta"></span></td></tr></table></blockquote><p><div class="SIntrapara">Here are some examples:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">a</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">c</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._assoc%29%29" class="RktValLink" data-pltdoc="x">assoc</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">#t</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect 2</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._assoc%29%29" class="RktValLink" data-pltdoc="x">assoc</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">z</span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">#t</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect 0</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here is one way the first example could expand (just the first step):
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">condition-value</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._assoc%29%29" class="RktValLink" data-pltdoc="x">assoc</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition-value</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition-value</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">#t</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>We update the definition of <span class="RktSym">cond-clause</span> by adding another
<span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span> clause for the new variant. Its second expression has a
different intepretation, so we should use a different name for its pattern
variable so that we don&rsquo;t confuse them:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">cond-clause</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">condition</span><span class="hspace">&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">!!</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktSym">get-result:expr</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>There&rsquo;s a problem, though. The new pattern is fine by itself, but it doesn&rsquo;t fit
with the existing <span class="RktPn">#:attributes</span> declaration. The second variant doesn&rsquo;t
have a simple <span class="RktSym">result</span> expression; it interprets its second expression
differently. The syntax class, though, needs a single interface that determines
what nested attributes are bound when the syntax class is used in a macro and
how the nested attributes are interpreted.</p><p><div class="SIntrapara">The interface between syntax class and macro is determined by how we allocate
reponsibility between the two for the interpretation of the syntax class&rsquo;s
terms. This problem is a fundamentally difficult one, and in general there is no
single right answer, but there are some standard <a name="(tech._interface._strategy)"></a><span style="font-style: italic">interface strategies</span>:
</div><div class="SIntrapara"><ul><li><p>empty interface (redo case analysis)</p></li><li><p>common meaning</p></li><li><p>macro behavior</p></li><li><p>code generation</p></li><li><p>AST</p></li></ul></div><div class="SIntrapara">Each has different tradeoffs, and some don&rsquo;t work in all situations. The
following sections discuss each approach in greater detail.</div></p><h5>6.1.1<tt>&nbsp;</tt><a name="(part._enum-empty)"></a>Empty Interface Strategy (Redo Case Analysis)</h5><p>One option is to give the syntax class no responsibility for interpreting its
terms, and simply redo the case analysis in the macro. This is the
<a name="(tech._empty._interface)"></a><span style="font-style: italic">empty interface</span> strategy. The syntax class is still useful for input
validation and as internal documentation, but since it performs no
interpretation, we should declare that it exports no attributes.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">cond-clause</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktSym">get-result:expr</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>The following version of <span class="RktSym">my-cond</span> checks the syntactic structure of all
of its arguments, then expands into a private recursive helper macro
<span class="RktSym">my-cond*</span>, which performs the case analysis on each clause again:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond CondClause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c:cond-clause</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">my-cond*</span><span class="hspace">&nbsp;</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond* CondClause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond*</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">result</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond*</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktSym">get-result:expr</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">condition-value</span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition-value</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">get-result</span><span class="hspace">&nbsp;</span><span class="RktSym">condition-value</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond*</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>An advantage of this strategy is that it is nearly always a viable option. A
disadvantage is that it duplicates syntax patterns, which introduces the
possibility of discrepancies between the syntax class and the macro
clauses. Such discrepancies can lead to problems that are difficult to catch and
debug.</p><blockquote class="SubFlow"><p><div class="SIntrapara"><a name="(exercise._enum-cond/empty)"></a><span style="font-weight: bold">Exercise&#160;11: </span>Extend the definition of <span class="RktCmt">CondClause</span>
with one more variant as follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClause</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">...</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">#:bind</span><span class="hspace">&nbsp;</span><span class="RktCmt">c:Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{c}]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">If the condition evaluates to a true value, it is bound to the given variable
name and the result expression is evaluated in the scope of that variable. The
scope of the variable does not include any other clauses.</div></p><p>Update the design of <span class="RktSym">cond-clause</span> and <span class="RktSym">my-cond</span> for the new
<span class="RktCmt">CondClause</span> variant using the strategy described in this section.</p></blockquote><h5>6.1.2<tt>&nbsp;</tt><a name="(part._enum-meaning)"></a>Common Meaning Interface Strategy</h5><p><div class="SIntrapara">In some cases, it is possible to find a <a name="(tech._common._meaning)"></a><span style="font-style: italic">common
meaning</span> shared by all of the variants that is also sufficient for the macro to
work with. In the case of <span class="RktCmt">CondClause</span>, this is relatively
straightforward: We can convert any &ldquo;normal&rdquo; clause into an &ldquo;apply&rdquo; clause
by wrapping it in a function that ignores its argument. For example, instead of
writing
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">e</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">o</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">we could instead write
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ignore</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">e</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ignore</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">o</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">That is, the second clause form is strictly more general than the first clause
form. We don&rsquo;t need to actually rewrite the whole clauses; instead, we can
change the attributes of <span class="RktSym">cond-clause</span> to <span class="RktSym">condition</span> and
<span class="RktSym">get-result</span> to represent the second form, and we can change the first
form to <span class="emph">compute</span> the <span class="RktSym">get-result</span> attribute using
<span class="RktPn">#:with</span>. Here is the new syntax class:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">cond-clause</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">condition</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Expr[(U #f C)]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">get-result</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Expr[C -&gt; Any]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:with</span><span class="hspace">&nbsp;</span><span class="RktSym">get-result</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ignore</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktSym">get-result:expr</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">I&rsquo;ve also added comments with shape annotations for the attributes, to help me
remember their intended interpretation.</div></p><p><div class="SIntrapara">Here is an implementation of <span class="RktSym">my-cond</span> using this version of
<span class="RktSym">cond-clause</span> and its attributes:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond CondClause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c:cond-clause</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">condition-value</span><span class="hspace">&nbsp;</span><span class="RktSym">c.condition</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition-value</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">c.get-result</span><span class="hspace">&nbsp;</span><span class="RktSym">condition-value</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>You might worry that introducing a <span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span> wrapper and a function call
for every simple clause form will make the generated code run slower. After all,
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span> requires a closure allocation, right? In this case, that is not
true. The generated <span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span> wrappers appear directly in application
position, and the Racket compiler is more than smart enough to inline those
applications away. So even though the new version of the macro expands to
different Racket code for simple clauses, the compiler produces exactly the same
compiled code, with zero run-time overhead.</p><blockquote class="SubFlow"><p><a name="(exercise._enum-cond/meaning)"></a><span style="font-weight: bold">Exercise&#160;12: </span>See <a href="#%28exercise._enum-cond%2Fempty%29" data-pltdoc="x">Exercise&#160;11</a> for a
revised definition of <span class="RktCmt">CondClause</span>. Update the design of
<span class="RktSym">cond-clause</span> and <span class="RktSym">my-cond</span> for the new <span class="RktCmt">CondClause</span> variant
using the strategy described in this section.</p></blockquote><h5>6.1.3<tt>&nbsp;</tt><a name="(part._enum-behavior)"></a>Macro Behavior Interface Strategy</h5><p>If it is difficult to find a common interface for all of a syntax class&rsquo;s
variants based solely on their contents, an alternative is to design the
interface based on the <a name="(tech._macro._behavior)"></a><span style="font-style: italic">macro behavior</span>. This is similar to shifting
from &ldquo;functional&rdquo; style operations defined separately from a data type to
&ldquo;object-oriented&rdquo; style methods where behavior is defined together with the
type and its variants. The potential downside, of course, is that it couples the
syntax class more tightly with the macro.</p><p><div class="SIntrapara">In this example, we can move the responsibility for testing the condition and
producing the result if the clause is selected from the macro to the syntax
class. What is left, then? If the clause is not selected (that is, the clause
&ldquo;fails&rdquo;), it needs to be told how to continue the search for an answer. We can
represent &ldquo;how to continue&rdquo; with a thunk of type <span class="RktCmt">(-&gt; Any)</span>; this
kind of thunk is traditionally called a &ldquo;failure continuation&rdquo;. (This sense of
the word &ldquo;continuation&rdquo; does not refer to the kind of value exposed by
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/cont.html#%28def._%28%28lib._racket%2Fprivate%2Fmore-scheme..rkt%29._call%2Fcc%29%29" class="RktValLink" data-pltdoc="x">call/cc</a></span>, etc.) So the whole clause is represented by a function that
takes a failure continuation and produces an answer; it has the type <span class="RktCmt">(-&gt;
Any) -&gt; Any</span>. We define <span class="RktSym">cond-clause</span> with a single attribute,
<span class="RktSym">code</span>, containing an expression for that function:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">cond-clause</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">code</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Expr[(-&gt; Any) -&gt; Any]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:with</span><span class="hspace">&nbsp;</span><span class="RktSym">code</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fail</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="hspace">&nbsp;</span><span class="RktSym">result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fail</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktSym">get-result:expr</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:with</span><span class="hspace">&nbsp;</span><span class="RktSym">code</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fail</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">condition-value</span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition-value</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">get-result</span><span class="hspace">&nbsp;</span><span class="RktSym">condition-value</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fail</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Now in the recursive case, the <span class="RktSym">my-cond</span> macro just calls the clause&rsquo;s
<span class="RktSym">code</span> with a failure continuation that tries the rest of the clauses:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond CondClause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c:cond-clause</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">c.code</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Again, you might worry that the use of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span> leads to run-time
inefficiency, but the way this macro uses <span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span> is easily optimized
away by the compiler.</p><blockquote class="SubFlow"><p><a name="(exercise._enum-cond/behavior)"></a><span style="font-weight: bold">Exercise&#160;13: </span>See <a href="#%28exercise._enum-cond%2Fempty%29" data-pltdoc="x">Exercise&#160;11</a> for a
revised definition of <span class="RktCmt">CondClause</span>. Update the design of
<span class="RktSym">cond-clause</span> and <span class="RktSym">my-cond</span> for the new <span class="RktCmt">CondClause</span> variant
using the strategy described in this section.</p></blockquote><h5>6.1.4<tt>&nbsp;</tt><a name="(part._enum-codegen)"></a>Code Generator Interface Strategy</h5><p><div class="SIntrapara">Suppose, though, that we really wanted to produce more natural looking code,
perhaps for readability. Here&rsquo;s a variation on the previous solution: Instead of
exporting a syntax-valued attribute that takes a run-time failure continuation,
export a <span class="emph">function-valued</span> attribute that takes a compile-time failure
<span class="emph">expression</span> and produces an expression implementing <span class="RktSym">my-cond</span>&rsquo;s
behavior for that clause. That is, the attribute represents a <a name="(tech._code._generator)"></a><span style="font-style: italic">code
generator</span> for the clause. For example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">cond-clause</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-code</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Syntax[Expr] -&gt; Syntax[Expr]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attr</span><span class="hspace">&nbsp;</span><span class="RktSym">make-code</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fail-expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#`</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="hspace">&nbsp;</span><span class="RktSym">result</span><span class="hspace">&nbsp;</span><span class="RktRdr">#,</span><span class="RktSym">fail-expr</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktSym">get-result:expr</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attr</span><span class="hspace">&nbsp;</span><span class="RktSym">make-code</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fail-expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#`</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">condition-value</span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition-value</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">get-result</span><span class="hspace">&nbsp;</span><span class="RktSym">condition-value</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#,</span><span class="RktSym">fail-expr</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Note that the <span class="RktSym">make-code</span> attribute is declared with a type, not a shape,
and it is defined using <span class="RktPn">#:attr</span> instead of <span class="RktPn">#:with</span>.</div></p><p><div class="SIntrapara">Here is the corresponding definition of <span class="RktSym">my-cond</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond CondClause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c:cond-clause</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Datum_Pattern_Matching.html#%28form._%28%28lib._syntax%2Fdatum..rkt%29._datum%29%29" class="RktStxLink" data-pltdoc="x">datum</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c.make-code</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>The value of <span class="RktSym">c.make-code</span> is not syntax, so we cannot use it in a syntax
template. We use <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Datum_Pattern_Matching.html#%28form._%28%28lib._syntax%2Fdatum..rkt%29._datum%29%29" class="RktStxLink" data-pltdoc="x">datum</a></span> to get the attribute value (a function), and
apply it to syntax representing an expression handling the rest of the clauses.</p><p><div class="SIntrapara">Here&rsquo;s another version of the macro that checks all of the clauses first and
then uses <span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._foldr%29%29" class="RktValLink" data-pltdoc="x">foldr</a></span> to process all of their code generators:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond CondClause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c:cond-clause</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._foldr%29%29" class="RktValLink" data-pltdoc="x">foldr</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-code</span><span class="hspace">&nbsp;</span><span class="RktSym">rec-expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-code</span><span class="hspace">&nbsp;</span><span class="RktSym">rec-expr</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Datum_Pattern_Matching.html#%28form._%28%28lib._syntax%2Fdatum..rkt%29._datum%29%29" class="RktStxLink" data-pltdoc="x">datum</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">c.make-code</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>The expression <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Datum_Pattern_Matching.html#%28form._%28%28lib._syntax%2Fdatum..rkt%29._datum%29%29" class="RktStxLink" data-pltdoc="x">datum</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">c.make-code</span><span class="stt"> </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span> has type <span class="RktCmt">(Listof
(Syntax[Expr] -&gt; Syntax[Expr]))</span>.</p><blockquote class="SubFlow"><p><a name="(exercise._enum-cond/codegen)"></a><span style="font-weight: bold">Exercise&#160;14: </span>See <a href="#%28exercise._enum-cond%2Fempty%29" data-pltdoc="x">Exercise&#160;11</a> for a
revised definition of <span class="RktCmt">CondClause</span>. Update the design of
<span class="RktSym">cond-clause</span> and <span class="RktSym">my-cond</span> for the new <span class="RktCmt">CondClause</span> variant
using the strategy described in this section.</p></blockquote><h5>6.1.5<tt>&nbsp;</tt><a name="(part._enum-ast)"></a>AST Interface Strategy</h5><p>The <a name="(tech._ast._strategy)"></a><span style="font-style: italic">AST strategy</span> is a variation on the <a href="#%28part._enum-empty%29" data-pltdoc="x">Empty Interface Strategy (Redo Case Analysis)</a> approach,
which has the macro redo the syntax class&rsquo;s case analysis. But in this
variation, instead of the macro doing case analysis on the syntax, the syntax
class parses its terms into values in some AST datatype, and then the macro does
case analysis on the AST values.</p><p>This results in a larger interface between the syntax class and the macro or
macros that use it, because the interface includes the AST datatype
definition. On the other hand, the syntax class does not have to specialize its
interpretation based on the behavior of any specific macro. Furthermore, the
case analysis performed by the macro can be simpler and faster, and errors will
be easier to catch and debug, compared to discrepancies between syntax class and
macro syntax patterns.</p><p><div class="SIntrapara">Here is a definition of an AST datatype (<span class="RktCmt">ClauseRep</span>) and a version of the
<span class="RktSym">cond-clause</span> syntax class that exports a single <span class="RktSym">ast</span> attribute
containing a <span class="RktCmt">ClauseRep</span> value:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A ClauseRep is an instance of one of the following:</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">clause:normal</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">condition</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Syntax[Expr]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Syntax[Expr]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">clause:apply</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">condition</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Syntax[Expr[(U #f C)]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">get-result</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Syntax[Expr[C -&gt; Any]]</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">cond-clause</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ast</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">ClauseRep</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attr</span><span class="hspace">&nbsp;</span><span class="RktSym">ast</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">clause:normal</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktSym">condition</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktSym">get-result:expr</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attr</span><span class="hspace">&nbsp;</span><span class="RktSym">ast</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">clause:apply</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktSym">condition</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktSym">get-result</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>The type <span class="RktCmt">ClauseRep</span> represents parsed terms of the shape
<span class="RktCmt">CondClause</span>. I&rsquo;ve given them separate names here for clarify, but in
practice I often use the same name for type and shape. The context usually
disambiguates them.</p><p><div class="SIntrapara">Here is one implementation of the <span class="RktSym">my-cond</span> macro, using <span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span>
to do case analysis on the clause ASTs:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-cond</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClause</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">my-cond</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">c:cond-clause</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._foldr%29%29" class="RktValLink" data-pltdoc="x">foldr</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">ast</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">rec-code</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ast</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">clause:normal</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">condition</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">result</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fqqstx..rkt%29._quasisyntax%29%29" class="RktStxLink" data-pltdoc="x">#`</a></span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fqqstx..rkt%29._unsyntax%29%29" class="RktStxLink" data-pltdoc="x">#,</a></span><span class="RktSym">condition</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fqqstx..rkt%29._unsyntax%29%29" class="RktStxLink" data-pltdoc="x">#,</a></span><span class="RktSym">result</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fqqstx..rkt%29._unsyntax%29%29" class="RktStxLink" data-pltdoc="x">#,</a></span><span class="RktSym">rec-code</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">clause:apply</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">condition</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">get-result</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fqqstx..rkt%29._quasisyntax%29%29" class="RktStxLink" data-pltdoc="x">#`</a></span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">condition-value</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fqqstx..rkt%29._unsyntax%29%29" class="RktStxLink" data-pltdoc="x">#,</a></span><span class="RktSym">condition</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">condition-value</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fqqstx..rkt%29._unsyntax%29%29" class="RktStxLink" data-pltdoc="x">#,</a></span><span class="RktSym">get-result</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">condition-value</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fqqstx..rkt%29._unsyntax%29%29" class="RktStxLink" data-pltdoc="x">#,</a></span><span class="RktSym">rec-code</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax%29%29" class="RktStxLink" data-pltdoc="x">#'</a></span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Datum_Pattern_Matching.html#%28form._%28%28lib._syntax%2Fdatum..rkt%29._datum%29%29" class="RktStxLink" data-pltdoc="x">datum</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">c.ast</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><blockquote class="SubFlow"><p><a name="(exercise._enum-cond/ast)"></a><span style="font-weight: bold">Exercise&#160;15: </span>See <a href="#%28exercise._enum-cond%2Fempty%29" data-pltdoc="x">Exercise&#160;11</a> for a
revised definition of <span class="RktCmt">CondClause</span>. Update the design of
<span class="RktSym">cond-clause</span> and <span class="RktSym">my-cond</span> for the new <span class="RktCmt">CondClause</span> variant
using the strategy described in this section. Double-check that a
<span class="RktPn">#:bind</span>-clause variable is not visible in subsequent clauses!</p></blockquote><h4>6.2<tt>&nbsp;</tt><a name="(part._enum-overlap)"></a>Designing Enumerated Syntax</h4><p>When you design an enumerated syntax shape, you must avoid ambiguity; or if you
cannot completely avoid it, you must manage it carefully. To elaborate, let&rsquo;s
consider some alternative syntaxes for cond-clauses.</p><p>For <span class="RktCmt">AltCondClauseV1</span>, let&rsquo;s generalize the simple form, so that the result
is determined not by a single expression but by one or more body terms. And
let&rsquo;s indicate the second form with the identifier <span class="RktSym"><a href="https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._apply%29%29" class="RktValLink" data-pltdoc="x">apply</a></span> instead of the
keyword <span class="RktPn">#:apply</span>.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">AltCondClauseV1</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Body</span><span class="hspace">&nbsp;</span><span class="RktCmt">...+]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">apply</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="RktMeta"></span></td></tr></table></blockquote><p>This syntax design is <span class="emph">bad</span>, because there are two variants with different
meanings that contain the same terms. In fact, every term that matches the
second variant also matches the first.</p><p>One could argue that a programmer is unlikely to simply write <span class="RktSym"><a href="https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._apply%29%29" class="RktValLink" data-pltdoc="x">apply</a></span> at
the beginning of a result body intending it to be evaluated as an expression. It
would have no effect; its presence would be completely useless. Still,
programmers regularly trip on &ldquo;out of the way&rdquo; inconsistencies, and it&rsquo;s a
better habit to keep comfortable safety margins.</p><p>Let&rsquo;s change the definition slightly so that instead of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._apply%29%29" class="RktValLink" data-pltdoc="x">apply</a></span>, we use
the identifier <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span> to indicate the second clause form:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">AltCondClauseV2</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Body</span><span class="hspace">&nbsp;</span><span class="RktCmt">...+]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">=&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="RktMeta"></span></td></tr></table></blockquote><p>This syntax design is okay; it is in fact the design Racket uses for
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span> clauses. There are two crucial details, though. First, the
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span> variant must be recognized not by the symbolic content of the
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span> identifier, but by checking whether it is a reference to Racket&rsquo;s
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span> binding. Second. Racket defines <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span> as a macro that always
signals a syntax error. So even though we can interpret <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span> as an
expression, it is never a <span class="emph">valid</span> expression. In practice, we only care
about avoiding overlaps with the set of valid expressions, so
<span class="RktCmt">AltCondClauseV2</span> is okay.</p><p>Both properties are needed to avoid ambiguity. If we checked for <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span> as
a symbol, then a programmer could define a local variable (or macro) named
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span>, which would then be a valid expression, so there would be
overlap. And if <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span> were a valid expression, that also creates an
overlap. (That&rsquo;s the problem with the <span class="RktSym"><a href="https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._apply%29%29" class="RktValLink" data-pltdoc="x">apply</a></span> variant in
<span class="RktCmt">AltCondClauseV1</span>.)</p><p><div class="SIntrapara">Finally, although the shape is okay, we must be careful when writing the
corresponding syntax patterns. First, we must declare <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span> as a
<span class="emph">literal</span>; otherwise it would be treated as another pattern variable. Here
is a first draft of the corresponding syntax class definition, based on the
&ldquo;macro behavior interface&rdquo; strategy:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">alt-cond-clause-v2</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">code</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Expr[(-&gt; Any) -&gt; Any]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:literals</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._......%2B%29%29" class="RktStxLink" data-pltdoc="x">...+</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:with</span><span class="hspace">&nbsp;</span><span class="RktSym">code</span><span class="hspace">&nbsp;</span><span class="RktVar">___</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span><span class="hspace">&nbsp;</span><span class="RktSym">get-result:expr</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:with</span><span class="hspace">&nbsp;</span><span class="RktSym">code</span><span class="hspace">&nbsp;</span><span class="RktVar">___</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">The problem is that a clause term like <span class="RktPn">[</span><span class="RktSym">a</span><span class="stt"> </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span><span class="stt"> </span><span class="RktSym">b</span><span class="RktPn">]</span> matches the first
pattern, and so the syntax class interprets it as a simple condition and
result-body clause. That is, the same issue we dealt with earlier at the shape
level shows up again at the syntax pattern level. It shows up again because even
though <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span> cannot be a valid expression, the <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span> syntax class
doesn&rsquo;t know that. This issue is not specific to syntax classes; it would also
come up if we did the case analysis in the macro patterns.</div></p><p>The solution involves two steps. First, reorder the patterns to put the
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span> pattern first. Second, use <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7e%21%29%29" class="RktStxLink" data-pltdoc="x">~!</a></span> (&ldquo;cut&rdquo;) to commit to the
first pattern after seeing <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span>. Here is the code:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">alt-cond-clause-v2</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">code</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Expr[(-&gt; Any) -&gt; Any]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:literals</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7e%21%29%29" class="RktStxLink" data-pltdoc="x">~!</a></span><span class="hspace">&nbsp;</span><span class="RktSym">get-result:expr</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:with</span><span class="hspace">&nbsp;</span><span class="RktSym">code</span><span class="hspace">&nbsp;</span><span class="RktVar">___</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._......%2B%29%29" class="RktStxLink" data-pltdoc="x">...+</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:with</span><span class="hspace">&nbsp;</span><span class="RktSym">code</span><span class="hspace">&nbsp;</span><span class="RktVar">___</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Without the <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7e%21%29%29" class="RktStxLink" data-pltdoc="x">~!</a></span>, a term like <span class="RktPn">[</span><span class="RktSym">a</span><span class="stt"> </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span><span class="stt"> </span><span class="RktSym">b</span><span class="stt"> </span><span class="RktSym">c</span><span class="RktPn">]</span> would be considered a
valid instance of the second pattern, rather than an invalid instance of the
first pattern. (Try it and see what happens!)</p><p>The complexity of overlaps with expressions is one reason that keywords were
introduced into Racket. Since both the <span class="RktCmt">Expr</span> shape and the <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._expr%29%29" class="RktStxLink" data-pltdoc="x">expr</a></span>
syntax class consider themselves completely disjoint from keywords, they avoid
these issues completely. (A related issue does emerge when dealing with
partly-expanded code, distinguishing definitions from expressions, for
example. We&rsquo;ll talk about that later. FIXME-REF)</p><h3>7<tt>&nbsp;</tt><a name="(part._multi-shapes)"></a>Multi-Term Shapes</h3><p>This section introduces &ldquo;multi-term&rdquo; shapes, used to describe syntactic
elements like keyword arguments.</p><h4>7.1<tt>&nbsp;</tt><a name="(part._multi-terms)"></a>Shapes for Multiple Terms</h4><p>In Racket, the syntax of a &ldquo;keyword argument&rdquo; to a function does not consist
of a single term; it consists of two terms, a keyword followed by the argument
term. That is, the logical grouping structure does not correspond with the term
structure. The syntax of macros generally follows the same idiom: a macro
keyword argument consists of the keyword and zero or more argument terms,
depending on the keyword. For example, the <span class="RktPn">#:attributes</span> keyword used by
<span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span> takes one argument (a list of attributes); and the
<span class="RktPn">#:with</span> keyword takes two (a syntax pattern and an expression).</p><p><div class="SIntrapara">We can define shapes that stand for multiple terms like this:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">AttributesClause</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktCmt">(Id</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">WithClause</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">#:with</span><span class="hspace">&nbsp;</span><span class="RktCmt">SyntaxPattern</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Multi-term shapes are represented by <span class="emph">splicing syntax classes</span>, which
encapsulate <span class="emph">head syntax patterns</span> (so called because they match some
variable-length &ldquo;head&rdquo; of the list term).</div></p><p><div class="SIntrapara">Let&rsquo;s extend <span class="RktSym">my-cond</span> with support for a <span class="RktPn">#:do</span> clause that has a
single <span class="RktCmt">Body</span> argument. That will allow us to include definitions between
tests. Here&rsquo;s an example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">a</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">c</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._assoc%29%29" class="RktValLink" data-pltdoc="x">assoc</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/booleans.html#%28def._%28%28quote._~23~25kernel%29._not%29%29" class="RktValLink" data-pltdoc="x">not</a></span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"not found"</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">value</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">value</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">even</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">value</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">odd</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here is the revised definition of <span class="RktCmt">CondClause</span>, which is now a multi-term
shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClause</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">#:apply</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">#:do</span><span class="hspace">&nbsp;</span><span class="RktCmt">Body</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here is the corresponding syntax class, including only the patterns:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-splicing-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-splicing-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">cond-clause</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktSym">get-result:expr</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7eseq%29%29" class="RktStxLink" data-pltdoc="x">~seq</a></span><span class="hspace">&nbsp;</span><span class="RktPn">#:do</span><span class="hspace">&nbsp;</span><span class="RktSym">body:expr</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">We must declare <span class="RktSym">my-cond</span> using <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-splicing-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-splicing-syntax-class</a></span>,
and we must use <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7eseq%29%29" class="RktStxLink" data-pltdoc="x">~seq</a></span> to wrap multiple-term patterns.</div></p><p><div class="SIntrapara">What interface can we give to the syntax class, and how do we implement the
macro? Let&rsquo;s review the implementations of <span class="RktSym">my-cond</span> from
<a href="#%28part._enum-shapes-def%29" data-pltdoc="x">Defining Enumerated Shapes</a>:
</div><div class="SIntrapara"><ul><li><p>The approach of redoing the case analysis from <a href="#%28part._enum-empty%29" data-pltdoc="x">Empty Interface Strategy (Redo Case Analysis)</a> would
also still work.</p></li><li><p>The approach from <a href="#%28part._enum-meaning%29" data-pltdoc="x">Common Meaning Interface Strategy</a> no longer works, because
<span class="RktPn">#:do</span> clauses are not a special case of <span class="RktPn">#:apply</span> clauses.</p></li><li><p>The failure-continuation approach from <a href="#%28part._enum-behavior%29" data-pltdoc="x">Macro Behavior Interface Strategy</a> no longer
works, because the scope of definitions within <span class="RktPn">#:do</span> clauses should
cover the rest of the clauses, but the failure continuation is received as a
closure value, and there&rsquo;s no way to affect its environment.</p></li><li><p>The code generator approach from <a href="#%28part._enum-codegen%29" data-pltdoc="x">Code Generator Interface Strategy</a> would still work,
since the code generator for the <span class="RktPn">#:do</span> clause can put the expression
representing the rest of the clauses in the scope of the <span class="RktPn">#:do</span>-clause&rsquo;s
definitions.</p></li><li><p>The AST approach from <a href="#%28part._enum-ast%29" data-pltdoc="x">AST Interface Strategy</a> would still work. We would need
to update the AST datatype with a new variant and update the macro&rsquo;s case
analysis to handle it.</p></li></ul></div></p><p>This is a good summary of how robust each of these strategies is to changes in
the shape.</p><h5>7.1.1<tt>&nbsp;</tt><a name="(part._multi-redo-case)"></a>Redo Case Analysis</h5><p>For the <a href="#%28tech._empty._interface%29" class="techoutside" data-pltdoc="x"><span class="techinside">empty interface</span></a>, we simply add a case to the private,
recursive macro:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-splicing-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-splicing-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">cond-clause</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktSym">get-result:expr</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7eseq%29%29" class="RktStxLink" data-pltdoc="x">~seq</a></span><span class="hspace">&nbsp;</span><span class="RktPn">#:do</span><span class="hspace">&nbsp;</span><span class="RktSym">body:expr</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond CondClause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c:cond-clause</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">my-cond*</span><span class="hspace">&nbsp;</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond* CondClause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond*</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">result</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond*</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktSym">get-result:expr</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">condition-value</span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition-value</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">get-result</span><span class="hspace">&nbsp;</span><span class="RktSym">condition-value</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond*</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">#:do</span><span class="hspace">&nbsp;</span><span class="RktSym">body:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">body</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-cond*</span><span class="hspace">&nbsp;</span><span class="RktSym">more</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><h5>7.1.2<tt>&nbsp;</tt><a name="(part._multi-codegen)"></a>Code Generator</h5><p>With the <a href="#%28tech._code._generator%29" class="techoutside" data-pltdoc="x"><span class="techinside">code generator</span></a> strategy, the new implementation simply involves
two changes to the old implementation. We must change
<span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span> to <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-splicing-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-splicing-syntax-class</a></span>, and we
must add the third variant as below. The definition of <span class="RktSym">my-clause</span> itself
does not change.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-splicing-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-splicing-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">cond-clause</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-code</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Syntax[Expr] -&gt; Syntax[Expr]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attr</span><span class="hspace">&nbsp;</span><span class="RktSym">make-code</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fail-expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#`</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="hspace">&nbsp;</span><span class="RktSym">result</span><span class="hspace">&nbsp;</span><span class="RktRdr">#,</span><span class="RktSym">fail-expr</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">condition:expr</span><span class="hspace">&nbsp;</span><span class="RktPn">#:apply</span><span class="hspace">&nbsp;</span><span class="RktSym">get-result:expr</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attr</span><span class="hspace">&nbsp;</span><span class="RktSym">make-code</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fail-expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#`</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">condition-value</span><span class="hspace">&nbsp;</span><span class="RktSym">condition</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktSym">condition-value</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">get-result</span><span class="hspace">&nbsp;</span><span class="RktSym">condition-value</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#,</span><span class="RktSym">fail-expr</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7eseq%29%29" class="RktStxLink" data-pltdoc="x">~seq</a></span><span class="hspace">&nbsp;</span><span class="RktPn">#:do</span><span class="hspace">&nbsp;</span><span class="RktSym">body:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attr</span><span class="hspace">&nbsp;</span><span class="RktSym">make-code</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fail-expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#`</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">body</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#,</span><span class="RktSym">fail-expr</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-cond CondClause ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c:cond-clause</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._foldr%29%29" class="RktValLink" data-pltdoc="x">foldr</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-code</span><span class="hspace">&nbsp;</span><span class="RktSym">rec-expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-code</span><span class="hspace">&nbsp;</span><span class="RktSym">rec-expr</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Datum_Pattern_Matching.html#%28form._%28%28lib._syntax%2Fdatum..rkt%29._datum%29%29" class="RktStxLink" data-pltdoc="x">datum</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">c.make-code</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><h5>7.1.3<tt>&nbsp;</tt><a name="(part._multi-ast)"></a>AST</h5><blockquote class="SubFlow"><p><a name="(exercise._multi-cond/ast)"></a><span style="font-weight: bold">Exercise&#160;16: </span>Adapt the solution from <a href="#%28part._enum-ast%29" data-pltdoc="x">AST Interface Strategy</a> to
support <span class="RktPn">#:do</span>-clauses.</p></blockquote><h4>7.2<tt>&nbsp;</tt><a name="(part._optional-shapes)"></a>Optional Shapes</h4><p><div class="SIntrapara">A common kind of multi-term shape is one that has two (or more variants), one of
which consists of zero terms. A good naming convention for such shapes and
syntax classes is to start them with &ldquo;maybe&rdquo; or &ldquo;optional&rdquo;. For example, we
could add an optional final <span class="RktPn">#:else</span> clause to <span class="RktSym">my-cond</span>, like this:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-cond</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClause</span><span class="hspace">&nbsp;</span><span class="RktCmt">...</span><span class="hspace">&nbsp;</span><span class="RktCmt">MaybeFinalCondClause)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">where <span class="RktCmt">MaybeFinalCondClause</span> is defined as follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">MaybeFinalCondClause</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">&#949;</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">#:else</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Here I&rsquo;ve used <span class="RktCmt">&#949;</span> to represent zero terms.</div></p><p><div class="SIntrapara">The corresponding syntax class for <span class="RktCmt">MaybeFinalCondClause</span> must be a
splicing syntax class. The interpretation of the possible final clause is that
it provides a condition-free result if none of the previous clauses were
selected; if absent, the result is <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span>. So we can represent the
interpretation with a single attribute holding an expression:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-splicing-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-splicing-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">maybe-final-cond-clause</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">result</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7eseq%29%29" class="RktStxLink" data-pltdoc="x">~seq</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:with</span><span class="hspace">&nbsp;</span><span class="RktSym">result</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7eseq%29%29" class="RktStxLink" data-pltdoc="x">~seq</a></span><span class="hspace">&nbsp;</span><span class="RktPn">#:else</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Here is the macro, starting from the code-generation implementation above. The
only changes are to the pattern and the use of <span class="RktRdr">#'</span><span class="RktSym">fc.result</span> instead of
<span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span> in the call to <span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._foldr%29%29" class="RktValLink" data-pltdoc="x">foldr</a></span>.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">c:cond-clause</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="hspace">&nbsp;</span><span class="RktSym">fc:maybe-final-cond-clause</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._foldr%29%29" class="RktValLink" data-pltdoc="x">foldr</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-code</span><span class="hspace">&nbsp;</span><span class="RktSym">rec-expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-code</span><span class="hspace">&nbsp;</span><span class="RktSym">rec-expr</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktSym">fc.result</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Datum_Pattern_Matching.html#%28form._%28%28lib._syntax%2Fdatum..rkt%29._datum%29%29" class="RktStxLink" data-pltdoc="x">datum</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">c.make-code</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><h4>7.3<tt>&nbsp;</tt><a name="(part._shapes-types-scopes)"></a>Shapes, Types, and Scopes (&#9733;)</h4><p>In <a href="#%28part._basic-id%29" data-pltdoc="x">The Id (Identifier) Shape</a> and <a href="#%28part._basic-type%29" data-pltdoc="x">Expressions, Types, and Contracts</a> we explored how to express
scoping and type relationships between parts of a shape. Can we extend the
notation to express the scoping of the <span class="RktPn">#:do</span> form of <span class="RktCmt">CondClause</span>?</p><p><div class="SIntrapara">Recall the example program:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">a</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">c</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(Listof (list Symbol Integer))</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._assoc%29%29" class="RktValLink" data-pltdoc="x">assoc</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktSym">ls</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(list Symbol Integer)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-cond</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/booleans.html#%28def._%28%28quote._~23~25kernel%29._not%29%29" class="RktValLink" data-pltdoc="x">not</a></span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"not found"</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">value</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._even~3f%29%29" class="RktValLink" data-pltdoc="x">even?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">value</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">even</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._odd~3f%29%29" class="RktValLink" data-pltdoc="x">odd?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">value</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">odd</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">How does each clause affect the environment of subsequent clauses? The first
clause has no effect on the environments of the following clauses. The second
clause adds a variable binding <span class="RktSym">value</span> with type <span class="RktCmt">Integer</span>. More
generally, since we could define multiple variables using <span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28quote._~23~25kernel%29._define-values%29%29" class="RktStxLink" data-pltdoc="x">define-values</a></span>
or combine definitions with <span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin%29%29" class="RktStxLink" data-pltdoc="x">begin</a></span>, each clause might bind a <span class="emph">set</span>
of variables, and each variable has a corresponding type. The first clause
produces no bindings (so <span class="RktCmt">&#8709;</span>, the empty set); the second set produces
<span class="RktCmt">{value:Integer}</span>; the third and fourth clauses also produce
<span class="RktCmt">&#8709;</span>. Let&rsquo;s add a parameter to <span class="RktCmt">CondClause</span> representing the bindings
it &ldquo;produces&rdquo; &#8212;<wbr></wbr> that is, the bindings it adds to the environments of
subsequent clauses. We need to change the way we write the shape definition:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClause[&#8709;]</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClause[&#8709;]</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">#:apply</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClause[&#916;]</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">#:do</span><span class="hspace">&nbsp;</span><span class="RktCmt">Body[&#916;]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">We need the same information from the <span class="RktCmt">Body</span> shape. Note that <span class="RktCmt">&#916;</span>
does not stand for a type; it stands for a set of pairs of names and types &#8212;<wbr></wbr>
that is, a fragment of a type environment.</div></p><p><div class="SIntrapara">In the second clause of this example, <span class="RktCmt">&#916;</span> is <span class="RktCmt">{value:Integer}</span>. That
is:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">#:do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">value</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">: CondClause[{value:Integer}]</span></p></blockquote></div><div class="SIntrapara">because
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">value</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cadr%29%29" class="RktValLink" data-pltdoc="x">cadr</a></span><span class="hspace">&nbsp;</span><span class="RktSym">entry</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">: Body[{value:Integer}]</span></p></blockquote></div></p><p>We also need to change the way we talk about lists of clauses. The notation
<span class="RktCmt">CondClause ...</span> doesn&rsquo;t give us a good way to talk about the relationship
between different clauses. Instead, let&rsquo;s define a multi-term shape called
<span class="RktCmt">CondClauses</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClauses</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">&#949;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClauses</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClause[&#916;]</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClauses{&#916;}</span><span class="RktMeta"></span></td></tr></table></blockquote><p>By <span class="RktCmt">CondClauses{&#916;}</span> I mean that all expressions, body terms, etc within
the clause are in the scope of the additional bindings described by
<span class="RktCmt">&#916;</span>. That is, an environment annotation is implicitly propagated to all of
a shape&rsquo;s sub-shapes. The second line says that in <span class="RktCmt">CondClauses</span> sequence,
if one clause produces some bindings, then subsequent clauses are in their scope.</p><p>Here are the shape definitions with the environment annotations made fully
explicit, where <span class="RktCmt">&#915;</span> stands for a type environment:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClause{&#915;}[&#8709;]</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr{&#915;}</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{&#915;}]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClause{&#915;}[&#8709;]</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Expr{&#915;}</span><span class="hspace">&nbsp;</span><span class="RktCmt">#:apply</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{&#915;}]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClause{&#915;}[&#916;]</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">#:do</span><span class="hspace">&nbsp;</span><span class="RktCmt">Body{&#915;}[&#916;]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClauses{&#915;}</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">&#949;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClauses{&#915;}</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClause[&#916;]</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClauses{&#915;,&#916;}</span><span class="RktMeta"></span></td></tr></table></blockquote><p><div class="SIntrapara">Finally, here is the shape of <span class="RktSym">my-cond</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-cond</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClauses)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">--</span><span class="hspace">&nbsp;</span><span class="RktCmt">implicit</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-cond</span><span class="hspace">&nbsp;</span><span class="RktCmt">CondClauses{&#915;})</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr{&#915;}</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">--</span><span class="hspace">&nbsp;</span><span class="RktCmt">explicit</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>That shows how to use the shape notation to specify type and scoping
relationships between components of shapes.</p><p>For many macros, it is probably unnecessary to put this level of detail in the
shape declarations. A more practical approach might be to limit the shapes to
specifying syntactic structure and interpretation, as we&rsquo;ve been doing, and
describe the scoping of shapes and macros in prose.</p><p>On the other hand, a more precise specification is sometimes useful when writing
macros with complicated binding structures. So keep this tool in mind in case
you need it.</p><h3>8<tt>&nbsp;</tt><a name="(part._rec-shapes)"></a>Recursive Shapes</h3><h4>8.1<tt>&nbsp;</tt><a name="(part._datum-shape)"></a>The Datum Shape</h4><p>The <span class="RktCmt">Datum</span> shape contains all number terms, identifier terms, and other
atomic terms, as well as all list, vector, hash, box, and prefab struct terms
containing <span class="RktCmt">Datum</span> elements. That is, <span class="RktCmt">Datum</span> contains any term the
corresponds to a <span class="RktSym"><a href="https://docs.racket-lang.org/reference/Reading.html#%28def._%28%28quote._~23~25kernel%29._read%29%29" class="RktValLink" data-pltdoc="x">read</a></span>able value.</p><p>The <span class="RktCmt">Datum</span> shape represents the intention to use the term as a literal
within a <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> expression, or to convert it to a compile-time value
using <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._syntax-~3edatum%29%29" class="RktValLink" data-pltdoc="x">syntax-&gt;datum</a></span>.</p><p>There is no syntax class corresponding to <span class="RktCmt">Datum</span>.</p><p><div class="SIntrapara">Let&rsquo;s design the macro <span class="RktSym">my-case1</span>, which is like <span class="RktSym">my-evcase1</span> from
<a href="#%28exercise._compound~3amy-evcase1%29" data-pltdoc="x">Exercise&#160;9</a> and <a href="#%28part._defshape-same-diff%29" data-pltdoc="x">Same Structure, Different Interpretation</a> except
that each clause&rsquo;s comparison value is given as a datum rather than an
expression. That is, the macro&rsquo;s shape is:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-case1</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">[Datum</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Here is an example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">my-case1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin%29%29" class="RktStxLink" data-pltdoc="x">begin</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._printf%29%29" class="RktValLink" data-pltdoc="x">printf</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"got a coin!\n"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">"nickel"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">10</span><span class="hspace">&nbsp;</span><span class="RktVal">"dime"</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">25</span><span class="hspace">&nbsp;</span><span class="RktVal">"quarter"</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect print once, "quarter"</span></td></tr></table></blockquote></div><div class="SIntrapara">Here is an implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-case1 Expr [Datum Expr] ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-case1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">to-match:expr</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">datum</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktSym">to-match</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Equality.html#%28def._%28%28quote._~23~25kernel%29._equal~3f%29%29" class="RktValLink" data-pltdoc="x">equal?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktSym">datum</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">result</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">I often spell out <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> in a syntax template when it is applied to a
term containing pattern variables, to remind myself that the <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span>d
&ldquo;constant&rdquo; can vary based on the macro&rsquo;s arguments.</div></p><p><div class="SIntrapara">Here is another implementation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(my-case1 Expr [Datum Expr] ...) : Expr</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-case1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">to-match:expr</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">datum</span><span class="hspace">&nbsp;</span><span class="RktSym">result:expr</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktSym">to-match</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Equality.html#%28def._%28%28quote._~23~25kernel%29._equal~3f%29%29" class="RktValLink" data-pltdoc="x">equal?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">tmp</span><span class="hspace">&nbsp;</span><span class="RktSym">datum</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">result</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">This implementation is <span class="emph">wrong</span>, because the <span class="RktCmt">Datum</span> arguments are not
used within a <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> expression. Never implicitly treat a <span class="RktCmt">Datum</span>
as an <span class="RktCmt">Expr</span>! One obvious problem is that not every datum is
self-quoting. The following example should return <span class="RktVal">"matched"</span>, but it
raises an error instead:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-case1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">123</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">123</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"matched"</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktErr">application: not a procedure;</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;</span><span class="RktErr">expected a procedure that can be applied to arguments</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">given: 123</span></p></td></tr></table></blockquote></div><div class="SIntrapara">Even a datum that is normally self-quoting can carry a lexical context with an
alternative <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._~23~25datum%29%29" class="RktStxLink" data-pltdoc="x">#%datum</a></span> binding that gives it some other behavior. For
example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let-syntax%29%29" class="RktStxLink" data-pltdoc="x">let-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._~23~25datum%29%29" class="RktStxLink" data-pltdoc="x">#%datum</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">stx</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._raise-syntax-error%29%29" class="RktValLink" data-pltdoc="x">raise-syntax-error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="hspace">&nbsp;</span><span class="RktVal">"no self-quoting!"</span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-case1</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">one</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">two</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">lots</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktErr">eval:7:0: #%datum: no self-quoting!</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">in: (#%datum . 1)</span></p></td></tr></table></blockquote></div><div class="SIntrapara">This particular example is admittedly uncommon. A more common problem is that
the datum is computed by a macro, and depending on how it is coerced to a syntax
object it may or may not get a lexical context with Racket&rsquo;s <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._~23~25datum%29%29" class="RktStxLink" data-pltdoc="x">#%datum</a></span>
binding. Avoid all of these problems by treating <span class="RktCmt">Datum</span> and <span class="RktCmt">Expr</span>
as distinct shapes. If you have a datum and you want an expression that
evaluates to the same value at run time, put the datum in a <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span>
expression.</div></p><blockquote class="SubFlow"><p><div class="SIntrapara"><a name="(exercise._little~3amy-case)"></a><span style="font-weight: bold">Exercise&#160;17: </span>Generalize <span class="RktSym">my-case1</span> to
<span class="RktSym">my-case</span>, which has a list of datums in each clause. That is, the macro
has the following shape:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-case</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="hspace">&nbsp;</span><span class="RktCmt">[(Datum</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr]</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p></blockquote><h4>8.2<tt>&nbsp;</tt><a name="(part._rec-datum)"></a>Datum as a Recursive Shape</h4><p><div class="SIntrapara">Could we write a definition of <span class="RktCmt">Datum</span> rather than treating it as a basic
(that is, primitive) shape? The full definition would be quite complicated,
since Racket has many kinds of <span class="RktSym"><a href="https://docs.racket-lang.org/reference/Reading.html#%28def._%28%28quote._~23~25kernel%29._read%29%29" class="RktValLink" data-pltdoc="x">read</a></span>able values, and it occasionally
adds new ones. Let&rsquo;s simplify the question to datum terms built from
identifiers, numbers, booleans, strings, and proper lists; let&rsquo;s call this shape
<span class="RktCmt">SimpleDatum</span>. We can define it as a <span class="emph">recursive shape</span> as follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">SimpleDatum</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">(SimpleDatum</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">SimpleAtom</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">SimpleAtom</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">Identifier</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">Number</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">Boolean</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">String</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">I have collected the base cases into a separate shape, <span class="RktCmt">SimpleAtom</span>, for
convenience.</div></p><p>Like the corresponding shapes, the <span class="RktSym">simple-datum</span> syntax class is
recursive; the <span class="RktSym">simple-atom</span> syntax class is not. Let&rsquo;s discuss
<span class="RktSym">simple-atom</span> first.</p><p><div class="SIntrapara">The <span class="RktSym">simple-atom</span> syntax class presents a challenge: There is a built-in
syntax class for identifiers (<span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._id%29%29" class="RktStxLink" data-pltdoc="x">id</a></span>), but how do we check whether a term
contains a number, a boolean, or a string? Given a syntax object, we can extract
the corresponding plain Racket value by calling <span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._syntax-~3edatum%29%29" class="RktValLink" data-pltdoc="x">syntax-&gt;datum</a></span>. Then we
can use the ordinary <span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._number~3f%29%29" class="RktValLink" data-pltdoc="x">number?</a></span>, <span class="RktSym"><a href="https://docs.racket-lang.org/reference/booleans.html#%28def._%28%28quote._~23~25kernel%29._boolean~3f%29%29" class="RktValLink" data-pltdoc="x">boolean?</a></span>, and <span class="RktSym"><a href="https://docs.racket-lang.org/reference/strings.html#%28def._%28%28quote._~23~25kernel%29._string~3f%29%29" class="RktValLink" data-pltdoc="x">string?</a></span>
predicates. An identifier is just a syntax object containing a symbol, so we can
cover the identifier case by adding a <span class="RktSym"><a href="https://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._symbol~3f%29%29" class="RktValLink" data-pltdoc="x">symbol?</a></span> predicate check to the
others. Finally, we perform this check using a <span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7efail%29%29" class="RktStxLink" data-pltdoc="x">~fail</a></span> pattern; if the
check fails, then the syntax class does not accept the term. Here is the
definition:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">simple-atom? : Any -&gt; Boolean</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">simple-atom?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._or%29%29" class="RktStxLink" data-pltdoc="x">or</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._symbol~3f%29%29" class="RktValLink" data-pltdoc="x">symbol?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._number~3f%29%29" class="RktValLink" data-pltdoc="x">number?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/booleans.html#%28def._%28%28quote._~23~25kernel%29._boolean~3f%29%29" class="RktValLink" data-pltdoc="x">boolean?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/strings.html#%28def._%28%28quote._~23~25kernel%29._string~3f%29%29" class="RktValLink" data-pltdoc="x">string?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">simple-atom</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(pattern a #:when (simple-atom? (syntax-&gt;datum #'a)))</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktPn">#:and</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7efail%29%29" class="RktStxLink" data-pltdoc="x">~fail</a></span><span class="hspace">&nbsp;</span><span class="RktPn">#:unless</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">simple-atom?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._syntax-~3edatum%29%29" class="RktValLink" data-pltdoc="x">syntax-&gt;datum</a></span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">In most cases, it is better to use <span class="RktPn">#:when</span> to perform checks like this,
but this is one of the few cases where we don&rsquo;t want a &ldquo;post-traversal&rdquo; check
that dominates other matching failures. The difference between the two only
affects the way errors are reported.</div></p><p><div class="SIntrapara">The <span class="RktSym">simple-datum</span> syntax class is straightforward. The recursive case in
the shape simply translates to a syntax pattern with recursive syntax class
annotations:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">simple-datum</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">elem:simple-datum</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktSym">atom:simple-atom</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>There are no attributes, because the only interpretation that
<span class="RktCmt">SimpleDatum</span> supports can be achieved with <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> or
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/stxops.html#%28def._%28%28quote._~23~25kernel%29._syntax-~3edatum%29%29" class="RktValLink" data-pltdoc="x">syntax-&gt;datum</a></span> on the term itself.</p><h4>8.3<tt>&nbsp;</tt><a name="(part._quasiquote)"></a>Quasiquotation</h4><p><div class="SIntrapara">Let&rsquo;s define <span class="RktSym">my-quasiquote</span>, a simple version of Racket&rsquo;s
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._quasiquote%29%29" class="RktStxLink" data-pltdoc="x">quasiquote</a></span> macro. Its argument has a shape like <span class="RktCmt">SimpleDatum</span>,
except that it can have &ldquo;escapes&rdquo; to Racket expressions so we can compute
values to insert into the result. The shape of the macro is the following:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(my-quasiquote</span><span class="hspace">&nbsp;</span><span class="RktCmt">QuasiDatum)</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">where <span class="RktCmt">QuasiDatum</span> is defined as follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">QuasiDatum</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">(escape</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expr)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">(QuasiDatum</span><span class="hspace">&nbsp;</span><span class="RktCmt">...)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">SimpleAtom</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">What does <span class="RktSym">escape</span> mean in this shape definition? That is, how do we
recognize the <span class="RktSym">escape</span> form of <span class="RktCmt">QuasiDatum</span>. There are two
possibilities: we could recognize <span class="RktSym">escape</span> either as a <span class="emph">symbolic
literal</span> or as a <span class="emph">reference literal</span>. For this example, we&rsquo;ll recognize
<span class="RktSym">escape</span> by reference; we&rsquo;ll show an example of symbolic literals later
in FIXME-REF.</div></p><p><div class="SIntrapara">Recognizing <span class="RktSym">escape</span> as a reference means that there must be a binding of
<span class="RktSym">escape</span> for the reference to refer to. Since we don&rsquo;t intend
<span class="RktSym">escape</span> to have any meaning as a Racket expression, we should define it
as a macro that always raises a syntax error:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">escape</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">stx</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._raise-syntax-error%29%29" class="RktValLink" data-pltdoc="x">raise-syntax-error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="hspace">&nbsp;</span><span class="RktVal">"illegal use of escape"</span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>The error only occurs if the macro is expanded by the Racket macro expander; our
macros and syntax classes can still recognize references to it without
triggering the error.</p><p><div class="SIntrapara">Now we can implement the <span class="RktSym">quasi-datum</span> syntax class. We declare
<span class="RktSym">escape</span> as a (reference) literal using <span class="RktPn">#:literals</span>; then
occurrences of <span class="RktSym">escape</span> in the syntax patterns are treated as literals
instead of as pattern variables. Here is the definition, without attributes:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">quasi-datum</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:literals</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">escape</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">escape</span><span class="hspace">&nbsp;</span><span class="RktSym">code:expr</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">elem:quasi-datum</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktSym">a:simple-atom</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">What interface should we give to the <span class="RktSym">quasi-datum</span> syntax class? Recall
the <a href="#%28tech._interface._strategy%29" class="techoutside" data-pltdoc="x"><span class="techinside">interface strategies</span></a> from <a href="#%28part._enum-shapes-def%29" data-pltdoc="x">Defining Enumerated Shapes</a>. Most of them are
applicable here; with the possible exception of the <a href="#%28tech._common._meaning%29" class="techoutside" data-pltdoc="x"><span class="techinside">common meaning</span></a>
approach. Let&rsquo;s use the <a href="#%28tech._macro._behavior%29" class="techoutside" data-pltdoc="x"><span class="techinside">macro behavior</span></a> strategy. The <span class="RktSym">my-quasiquote</span>
interprets <span class="RktCmt">QuasiDatum</span> as instructions to construct a value from a
mixture of constants and values computed by escaped Racket expressions. We can
represent that with a syntax attribute, <span class="RktSym">code</span>, containing an expression
that produces the <span class="RktCmt">QuasiDatum</span>&rsquo;s value. Here is the definition:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">quasi-datum</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">code</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:literals</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">escape</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">escape</span><span class="hspace">&nbsp;</span><span class="RktSym">code:expr</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">elem:quasi-datum</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:with</span><span class="hspace">&nbsp;</span><span class="RktSym">code</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktSym">elem.code</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktSym">a:simple-atom</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:with</span><span class="hspace">&nbsp;</span><span class="RktSym">code</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">That is, the <span class="RktSym">escape</span> form contains the necessary expression directly;
the list form constructs a list from the values constructed by its components;
and an atom is interpreted as a value by quoting it.</div></p><p><div class="SIntrapara">The macro simply expands into its argument&rsquo;s <span class="RktSym">code</span> expression:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-syntax%29%29" class="RktStxLink" data-pltdoc="x">define-syntax</a></span><span class="hspace">&nbsp;</span><span class="RktSym">my-quasiquote</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parser%29%29" class="RktStxLink" data-pltdoc="x">syntax-parser</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">qd:quasi-datum</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktSym">qd.code</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here are some examples:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-quasiquote</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">abc</span><span class="hspace">&nbsp;</span><span class="RktSym">xyz</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(1 2 () abc xyz)</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-quasiquote</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">escape</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(1 2 3)</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-quasiquote</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">expression</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">value</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">escape</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'((expression (+ 1 2)) (value 3))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-quasiquote</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">b</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">d</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">escape</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._string-~3esymbol%29%29" class="RktValLink" data-pltdoc="x">string-&gt;symbol</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"g"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(a (b (c (d (e (f g))))))</span></p></td></tr></table></blockquote></div></p><p><div class="SIntrapara">The behavior of this example is questionable, though:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-quasiquote</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">escape</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(1 2 (escape 3 4))</span></p></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Do we want <span class="RktPn">(</span><span class="RktSym">escape</span><span class="stt"> </span><span class="RktVal">3</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">)</span> to be interpreted as a three-element list, or
do we want to consider it an ill-formed <span class="RktSym">escape</span> form and report an
error? I prefer to consider it an error. That is, whenever the <span class="RktSym">quasi-datum</span>
parser gets a term that starts <span class="RktPn">(</span><span class="RktSym">escape</span><span class="stt"> </span><span style="color: lightgray">&#9251;</span><span class="stt"> </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span>, it should
<span class="emph">commit</span> to parsing it according to the <span class="RktSym">escape</span> pattern. This
problem is similar to the problem with <span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29" class="RktStxLink" data-pltdoc="x">=&gt;</a></span> clauses in
<a href="#%28part._enum-overlap%29" data-pltdoc="x">Designing Enumerated Syntax</a>. The solution is the same too: We must put the
<span class="RktSym">escape</span> pattern before any other pattern it might overlap with, and we
must add a cut (<span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7e%21%29%29" class="RktStxLink" data-pltdoc="x">~!</a></span>) immediately after the <span class="RktSym">escape</span> literal. Here
is the updated code:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">quasi-datum</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">code</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:literals</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">escape</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">escape</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-patterns.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._~7e%21%29%29" class="RktStxLink" data-pltdoc="x">~!</a></span><span class="hspace">&nbsp;</span><span class="RktSym">code:expr</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">elem:quasi-datum</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:with</span><span class="hspace">&nbsp;</span><span class="RktSym">code</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktSym">elem.code</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktSym">a:simple-atom</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:with</span><span class="hspace">&nbsp;</span><span class="RktSym">code</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Now the example signals an error instead:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-quasiquote</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">escape</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">eval:23:0: my-quasiquote: unexpected term</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">at: 4</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">in: (my-quasiquote (1 2 (escape 3 4)))</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">parsing context: </span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">while parsing quasi-datum</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">term: (escape 3 4)</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">location: eval:23:0</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">while parsing quasi-datum</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">term: (1 2 (escape 3 4))</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">location: eval:23:0</span></p></td></tr></table></blockquote></div></p><p><div class="SIntrapara">There&rsquo;s one remaining issue with this implementation. Consider the following
example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">my-quasiquote</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(1 2 3 4 5)</span></p></td></tr></table></blockquote></div><div class="SIntrapara">This example has no escapes, so its result could be implemented with a simple
<span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> expression. But this is how the macro expands:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">my-quasiquote</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td>&#8658;</td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Let&rsquo;s optimize <span class="RktSym">my-quasiquote</span> so that it uses <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> at the
highest levels possible. Here&rsquo;s one strategy: we add an boolean-valued
<span class="RktSym">const?</span> attribute that is true when a term has no escapes. A list
<span class="RktCmt">QuasiDatum</span> is constant if all of its elements are constant; in that
case, its code can be simply the quotation of the elements. Here is the updated
syntax class:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/begin.html#%28form._%28%28quote._~23~25kernel%29._begin-for-syntax%29%29" class="RktStxLink" data-pltdoc="x">begin-for-syntax</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._define-syntax-class%29%29" class="RktStxLink" data-pltdoc="x">define-syntax-class</a></span><span class="hspace">&nbsp;</span><span class="RktSym">quasi-datum</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attributes</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">const?</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Boolean</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">code</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:literals</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">escape</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">escape</span><span class="hspace">&nbsp;</span><span class="RktSym">code:expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attr</span><span class="hspace">&nbsp;</span><span class="RktSym">const?</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">elem:quasi-datum</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attr</span><span class="hspace">&nbsp;</span><span class="RktSym">const?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._andmap%29%29" class="RktValLink" data-pltdoc="x">andmap</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/values.html#%28def._%28%28quote._~23~25kernel%29._values%29%29" class="RktValLink" data-pltdoc="x">values</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Datum_Pattern_Matching.html#%28form._%28%28lib._syntax%2Fdatum..rkt%29._datum%29%29" class="RktStxLink" data-pltdoc="x">datum</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">elem.const?</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:with</span><span class="hspace">&nbsp;</span><span class="RktSym">code</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/Datum_Pattern_Matching.html#%28form._%28%28lib._syntax%2Fdatum..rkt%29._datum%29%29" class="RktStxLink" data-pltdoc="x">datum</a></span><span class="hspace">&nbsp;</span><span class="RktSym">const?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">elem</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktSym">elem.code</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/syntax/stxparse-specifying.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._pattern%29%29" class="RktStxLink" data-pltdoc="x">pattern</a></span><span class="hspace">&nbsp;</span><span class="RktSym">a:simple-atom</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:attr</span><span class="hspace">&nbsp;</span><span class="RktSym">const?</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:with</span><span class="hspace">&nbsp;</span><span class="RktSym">code</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><blockquote class="SubFlow"><p><a name="(exercise._rec~3aqq-rec)"></a><span style="font-weight: bold">Exercise&#160;18: </span>Implement <span class="RktSym">quasi-datum</span> and
<span class="RktSym">my-quasiquote</span> (the unoptimized version) according to the <a href="#%28tech._empty._interface%29" class="techoutside" data-pltdoc="x"><span class="techinside">empty
interface</span></a> strategy and a recursive <span class="RktSym">my-quasiquote</span> macro. Is it possible
to implement the <span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> optimization using this approach?</p></blockquote><blockquote class="SubFlow"><p><div class="SIntrapara"><a name="(exercise._rec~3aqq-ignore)"></a><span style="font-weight: bold">Exercise&#160;19: </span>Extend the definition of <span class="RktCmt">QuasiDatum</span> as
follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">QuasiDatum</span><span class="hspace">&nbsp;</span><span class="RktCmt">::=</span><span class="hspace">&nbsp;</span><span class="RktCmt">...</span><span class="hspace">&nbsp;</span><span class="RktCmt">|</span><span class="hspace">&nbsp;</span><span class="RktCmt">(cellophane</span><span class="hspace">&nbsp;</span><span class="RktCmt">QuasiDatum)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">A <span class="RktSym">cellophane</span> wrapper is simply discarded from the constructed value;
that is, the <span class="RktCmt">QuasiDatum</span> <span class="RktPn">(</span><span class="RktSym">cellophane</span><span class="stt"> </span><span class="RktVar">qd</span><span class="RktPn">)</span> is equivalent to
<span class="RktVar">qd</span>. For example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">my-quasiquote</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cellophane</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">escape</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect '(1 2 3 4)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">my-quasiquote</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cellophane</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cellophane</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cellophane</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">expect '(1 2 3)</span></td></tr></table></blockquote></div></p><p>Start with the unoptimized version of the <span class="RktSym">quasi-datum</span> syntax class
using the <a href="#%28tech._macro._behavior%29" class="techoutside" data-pltdoc="x"><span class="techinside">macro behavior</span></a> strategy. After you have updated (and tested)
that version, implement a similar optimization for the updated
<span class="RktCmt">QuasiDatum</span> shape. For example, the second example above should expand
directly to <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span>. (Hint: What assumption made by the
original optimization does the updated shape violate?)</p></blockquote></div></div><div id="contextindicator">&nbsp;</div></body></html>